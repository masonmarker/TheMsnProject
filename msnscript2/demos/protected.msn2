# demonstrates usage of private() and exportas() to make a block thread safe
# see /demos/shared.msn2 for a more accurate demonstration of critical sections
# author : Mason Marker
# date : 11/10/2022

# fresh console
console('clear')

# simulates a semaphore, not the same semaphore structure as in /lib
var('sem',1)

# simulates waiting on a semaphore
~ sem_wait()->sem
-- wait(?sem? == 1)
-- sub('sem', 1)

# simulates posting a semaphore
~ sem_post()->sem
-- add('sem', 1)

# offers a generous amount of time to the semaphore to the opposing thread
# to avoid starvation
~ offer_sem()->sem
-- sleep(.01)

# first thread
thread('thread1', =>(
    for (0, 5, 'i', =>(

        # privately exporting a variable as a function call's return value
        # creates a hidden context when executing the function, 
        # avoiding interference with other threads that may
        # attempt to run the function at the same time
        private(exportas('sem', sem_wait())),

        # ------------------
        #  critical section

        print('thread 1: i have the thing'),

        # ------------------

        # give up semaphore
        private(exportas('sem', sem_post())),

        # give certain amount of time to verify opposing thread has finished its job
        offer_sem()
    ))
))

# second thread
thread('thread2', =>(
    for (0, 5, 'i2', =>(

        # waiting for semaphore to become available
        private(exportas('sem', sem_wait())),

        # ------------------
        #  critical section

        print('thread 2: now i have the thing'),

        # ------------------

        # give up semaphore
        private(exportas('sem', sem_post())),


         # give certain amount of time to verify opposing thread has finished its job
        offer_sem()
    ))
))




# if synchronized correctly, t2 will finish last,
# so we join with t2
join('thread2')

# shutdown
print('main: shutting down')