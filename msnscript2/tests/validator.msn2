# validates integrity of the current MSNScript2 interpreter
#
# author : Mason Marker
# date : 11/27/2022


# NOTE : ?? SYNTAX SHOULD NOT BE USED IN USER PROGRAMS (your programs)
# ?? is used in very specific cases to ensure integrity, you should use type specific methods instead


# ------------------ SETUP ------------------

# imports operating system specific 'clear' console command
import ('lib/os.msn2')

# imports timing capabilities
import ('lib/timer.msn2')

# test specific accounting
var('thread_count', 0)


# accumulates the thread count for private contexts
~ add_threads() -> _
    -- add('thread_count', << len(vars()['self'].threads) >>)

~ add_and_export() -> _
    -- add('thread_count', << len(vars()['self'].threads) >>)
    -- export('thread_count')

# prints accounting information
~ print_threads() -> _
    -- print('[+] created', ?thread_count?, 'threads')
    -- print('[+] interpreted', trace.len(), 'instructions')

# clear console
clear()

# -------------------------------------------

print('[+] starting, do not crtl + c / z')

# testing variables
var('a', 1)
var('b', 2)
var('c', 3)
var('d', 4)
var('e', 5)
var('f', 6)


# ------------------ VARIABLES ------------------

# tests basic variable functions
~ test_var() -> _

    -- print('[+] testing variables...')

    # asserts all variables exist in this context
    -- assert(exists('a'), exists('b'), exists('c'), exists('d'), exists('e'), exists('f'))

    # asserts that variables are being set correctly
    -- assert(?a? == 1, ?b? == 2, ?c? == 3, ?d? == 4, ?e? == 5, ?f? == 6)

    # asserts that variables are compared correctly
    -- assert(?a? < ?b?, ?b? < ?c?, ?c? < ?d?, ?d? < ?e?, ?e? < ?f?)

    # asserts that variables are being modified correctly
    -- var('a', 2)
    -- var('b', 3)
    -- var('c', 4)
    -- var('d', 5)
    -- var('e', 6)
    -- var('f', 7)

    -- assert(?a? == 2, ?b? == 3, ?c? == 4, ?d? == 5, ?e? == 6, ?f? == 7)

    # modifying variables in place
    -- add('a', 1)
    -- add('b', 1)
    -- add('c', 1)
    -- add('d', 1)
    -- add('e', 1)
    -- add('f', 1)

    -- assert(?a? == 3, ?b? == 4, ?c? == 5, ?d? == 6, ?e? == 7, ?f? == 8)

    -- sub('a', 1)
    -- sub('b', 1)
    -- sub('c', 1)
    -- sub('d', 1)
    -- sub('e', 1)
    -- sub('f', 1)

    -- assert(?a? == 2, ?b? == 3, ?c? == 4, ?d? == 5, ?e? == 6, ?f? == 7)

    -- mul('a', 2)
    -- mul('b', 2)
    -- mul('c', 2)
    -- mul('d', 2)
    -- mul('e', 2)
    -- mul('f', 2)

    -- assert(?a? == 4, ?b? == 6, ?c? == 8, ?d? == 10, ?e? == 12, ?f? == 14)

    -- div('a', 2)
    -- div('b', 2)
    -- div('c', 2)
    -- div('d', 2)
    -- div('e', 2)
    -- div('f', 2)

    -- assert(?a? == 2, ?b? == 3, ?c? == 4, ?d? == 5, ?e? == 6, ?f? == 7)


    -- var('_', True)


# -------------------------------------------



# ------------------ MATH ------------------

# tests basic math functions   
~ test_math() -> _

    -- print('[+] testing math...')

    # asserts addition works correctly
    -- assert(1 + 1 == 2, 2 + 2 == 4, 3 + 3 == 6, 4 + 4 == 8, 5 + 5 == 10, 6 + 6 == 12)

    # asserts subtraction works correctly
    -- assert(1 - 1 == 0, 2 - 2 == 0, 3 - 3 == 0, 4 - 4 == 0, 5 - 5 == 0, 6 - 6 == 0)

    # asserts multiplication works correctly
    -- assert(1 * 1 == 1, 2 * 2 == 4, 3 * 3 == 9, 4 * 4 == 16, 5 * 5 == 25, 6 * 6 == 36)

    # asserts division works correctly
    -- assert(1 / 1 == 1, 2 / 2 == 1, 3 / 3 == 1, 4 / 4 == 1, 5 / 5 == 1, 6 / 6 == 1)

    # asserts modulo works correctly
    -- assert(1 % 1 == 0, 2 % 2 == 0, 3 % 3 == 0, 4 % 4 == 0, 5 % 5 == 0, 6 % 6 == 0)

    # asserts exponentiation works correctly
    -- assert(1 ** 1 == 1, 2 ** 2 == 4, 3 ** 3 == 27, 4 ** 4 == 256, 5 ** 5 == 3125, 6 ** 6 == 46656)

    # asserts that integer division works correctly
    -- assert(1 // 1 == 1, 2 // 2 == 1, 3 // 3 == 1, 4 // 4 == 1, 5 // 5 == 1, 6 // 6 == 1)

    # modifies variables
    -- var('a', 2)
    -- var('b', 3)
    -- var('c', 4)
    -- var('d', 5)
    -- var('e', 6)
    -- var('f', 7)

    # asserts the same for variables
    -- assert(?a? + ?a? == 4, ?b? + ?b? == 6, ?c? + ?c? == 8, ?d? + ?d? == 10, ?e? + ?e? == 12, ?f? + ?f? == 14)
    -- assert(?a? - ?a? == 0, ?b? - ?b? == 0, ?c? - ?c? == 0, ?d? - ?d? == 0, ?e? - ?e? == 0, ?f? - ?f? == 0)
    -- assert(?a? * ?a? == 4, ?b? * ?b? == 9, ?c? * ?c? == 16, ?d? * ?d? == 25, ?e? * ?e? == 36, ?f? * ?f? == 49)
    -- assert(?a? / ?a? == 1, ?b? / ?b? == 1, ?c? / ?c? == 1, ?d? / ?d? == 1, ?e? / ?e? == 1, ?f? / ?f? == 1)
    -- assert(?a? % ?a? == 0, ?b? % ?b? == 0, ?c? % ?c? == 0, ?d? % ?d? == 0, ?e? % ?e? == 0, ?f? % ?f? == 0)
    -- assert(?a? ** ?a? == 4, ?b? ** ?b? == 27, ?c? ** ?c? == 256, ?d? ** ?d? == 3125, ?e? ** ?e? == 46656, ?f? ** ?f? == 823543)
    -- assert(?a? // ?a? == 1, ?b? // ?b? == 1, ?c? // ?c? == 1, ?d? // ?d? == 1, ?e? // ?e? == 1, ?f? // ?f? == 1)

    # working with floats
    -- var('a', 2.0)
    -- var('b', 3.0)
    -- var('c', 4.0)
    -- var('d', 5.0)
    -- var('e', 6.0)
    -- var('f', 7.0)

    # asserts the same for variables
    -- assert(?a? + ?a? == 4.0, ?b? + ?b? == 6.0, ?c? + ?c? == 8.0, ?d? + ?d? == 10.0, ?e? + ?e? == 12.0, ?f? + ?f? == 14.0)
    -- assert(?a? - ?a? == 0.0, ?b? - ?b? == 0.0, ?c? - ?c? == 0.0, ?d? - ?d? == 0.0, ?e? - ?e? == 0.0, ?f? - ?f? == 0.0)
    -- assert(?a? * ?a? == 4.0, ?b? * ?b? == 9.0, ?c? * ?c? == 16.0, ?d? * ?d? == 25.0, ?e? * ?e? == 36.0, ?f? * ?f? == 49.0)
    -- assert(?a? / ?a? == 1.0, ?b? / ?b? == 1.0, ?c? / ?c? == 1.0, ?d? / ?d? == 1.0, ?e? / ?e? == 1.0, ?f? / ?f? == 1.0)
    -- assert(?a? % ?a? == 0.0, ?b? % ?b? == 0.0, ?c? % ?c? == 0.0, ?d? % ?d? == 0.0, ?e? % ?e? == 0.0, ?f? % ?f? == 0.0)
    -- assert(?a? ** ?a? == 4.0, ?b? ** ?b? == 27.0, ?c? ** ?c? == 256.0, ?d? ** ?d? == 3125.0, ?e? ** ?e? == 46656.0, ?f? ** ?f? == 823543.0)
    -- assert(?a? // ?a? == 1.0, ?b? // ?b? == 1.0, ?c? // ?c? == 1.0, ?d? // ?d? == 1.0, ?e? // ?e? == 1.0, ?f? // ?f? == 1.0)

    # working with negative numbers and larger decimals
    -- var('a', -2.532)
    -- var('b', -3.123)
    -- var('c', -4.123)
    -- var('d', -5.123)
    -- var('e', -6.123)
    -- var('f', -7.123)

    # asserts the same for variables
    -- assert(?a? + ?a? == -5.064, ?b? + ?b? == -6.246, ?c? + ?c? == -8.246, ?d? + ?d? == -10.246, ?e? + ?e? == -12.246, ?f? + ?f? == -14.246)
    -- assert(?a? - ?a? == 0.0, ?b? - ?b? == 0.0, ?c? - ?c? == 0.0, ?d? - ?d? == 0.0, ?e? - ?e? == 0.0, ?f? - ?f? == 0.0)
    -- assert(equals(round(?a? * ?a?), 6))
    -- assert(equals(round(?b? * ?b?), 10))
    -- assert(equals(round(?c? * ?c?), 17))
    -- assert(equals(round(?d? * ?d?), 26))
    -- assert(equals(round(?e? * ?e?), 37))
    -- assert(equals(round(?f? * ?f?), 51))

    -- assert(?a? / ?a? == 1.0, ?b? / ?b? == 1.0, ?c? / ?c? == 1.0, ?d? / ?d? == 1.0, ?e? / ?e? == 1.0, ?f? / ?f? == 1.0)

    -- var('_', True)
# -------------------------------------------




# ------------------ STRINGS ------------------

~ test_strings() -> _

    -- print('[+] testing strings...')

    # modifies variables
    -- var('a', 'hello')
    -- var('b', 'world')
    
    # asserts that strings are being set correctly
    -- assert(?a? == 'hello', ?b? == 'world')

    # asserts that strings are being concatenated correctly
    -- assert(?a? + ?b? == 'helloworld')

    # asserts that strings are being multiplied correctly
    -- assert(?a? * 2 == 'hellohello', ?b? * 2 == 'worldworld')

    # asserts that strings are being modified correctly
    -- add('a', 'hello')
    -- assert(?a? == 'hellohello')

    # replacing with converge operator <<>> (python fallback mechanism)
    -- assert(<<|?a?|.replace('hello', '') == ''>>)

    # replacing with converge operator <<>> (python fallback mechanism)
    -- assert(<<|?a?|.replace('hello', 'world') == 'worldworld'>>)

    # splitting with converge operator <<>> (python fallback mechanism)
    -- assert(<<|?a?|.split('h') == ['', 'ello', 'ello']>>)

    # getting a character in a string
    -- assert(?a?[0] == 'h')
    -- assert(?a?[1] == 'e')
    -- assert(?a?[2] == 'l')
    -- assert(?a?[3] == 'l')
    -- assert(?a?[4] == 'o')

    # special characters
    -- assert('\\' == '\\', '\'' == '\'', '\"' == '\"', '\n' == '\n', '\t' == '\t', '\r' == '\r')

    -- var('a', 'hello')

    -- a.add(' how are you?')
    -- assert(?a? == 'hello how are you?')    

    -- a.add('\n')

    # when working with special characters, you cannot use ?? syntax
    -- var('checker', 'hello how are you?\n')
    -- assert(var.equals('a', 'checker'))

    -- var('_', True)

# -------------------------------------------


# ------------------ ARRAYS AND DICTIONARIES ------------------

~ test_arrays() -> _

    -- print('[+] testing arrays...')

    # sets an array
    -- var('a', [1, 2, 3, 4, 5, 6])

    # asserts that the array is being set correctly
    -- assert(?a? == [1, 2, 3, 4, 5, 6])

    # asserts that the array is being concatenated correctly
    -- assert(?a? + [7, 8, 9, 10, 11, 12] == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

    # asserts that the array is being multiplied correctly
    -- assert(?a? * 2 == [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])

    # asserts that the array is being modified correctly
    -- a.push(7, 8, 9)
    -- assert(?a? == [1, 2, 3, 4, 5, 6, 7, 8, 9])
    -- a . push(10)
    -- assert(?a? == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

    # asserts that removen() works correctly
    -- a.push(3, 3, 3)

    # removes 2 3's from 'a'
    -- a.removen(2, 3)

    -- assert(?a? == [1, 2, 4, 5, 6, 7, 8, 9, 10, 3, 3])

    # removes 1 '1' and 1 '2' from 'a'
    -- a.removen(1, 1, 2)

    -- assert(?a? == [4, 5, 6, 7, 8, 9, 10, 3, 3])

    # remove if not exists, catches value error
    -- try(a.removen(1, 1))

    -- assert(?a? == [4, 5, 6, 7, 8, 9, 10, 3, 3])

    # tests remove
    -- a.remove(3)

    -- assert(?a? == [4, 5, 6, 7, 8, 9, 10])

    # assert contains (<<>> python fallback)
    -- assert(<< 4 in |?a?| and 5 in |?a?| and 6 in |?a?| and 7 in |?a?| and 8 in |?a?| and 9  in |?a?| and 10 in |?a?| >>)
    -- assert(<< 1 not in |?a?| and 2 not in |?a?| and 3 not in |?a?| >>)

    # indexing dictionaries
    -- @dict = { 'a': 1, 'b': [0, [4, 3]], 'c': 3, 'd': 4, 'e': {'key': 'value'}, 'f': 6 }
    -- assert(?dict?['a'] == 1)

    # WIP
    -- dict.setn(999, 'e', 'key')   
    -- assert(?dict?['e']['key'] == 999)

    -- dict.setn(999, 'b', 1, 1)
    -- assert(?dict?['b'][1][1] == 999)

    -- dict.setn(999, 'b', 1)
    -- assert(?dict?['b'][1] == 999)

    -- dict.setn(999, 'b')
    -- assert(?dict?['b'] == 999)

    -- dict.setn(999, 'a')
    -- assert(?dict?['a'] == 999)
    -- dict.setn(999, 'f')
    -- assert(?dict?['f'] == 999)

    # deep dictionary operations
    -- @deep={'1':{'2':{'3':{'4':{}}}}}
    -- deep.setn(999, '1', '2', '3', '4', '5')
    -- assert(?deep?['1']['2']['3']['4']['5'] == 999)



    # testing the unpack() system call
    -- unpack([100, 101, 102, 103], 'a', 'b', 'c', 'd')

    -- assert(?a? == 100)
    -- assert(?b? == 101)
    -- assert(?c? == 102)
    -- assert(?d? == 103)

    # testing again
    -- unpack(['hello', 'bro'], 'a', 'b')

    -- assert(equals(a , 'hello'))
    -- assert(equals(b, 'bro'))

    -- var('_', True)

# -------------------------------------------

# ------- MSN2 EMBEDDING -------

# enables embedding of msn2 code in msn2 code
#
# <2> ... </2> -> msn2 code
# any pair of '%' will be replaced with the evaluation of the inner msn2 code
# <2> %...% </2> -> msn2 code
#
# whats inside of the <2> </2> tags will be evaluated and the result will be returned
~ test_msn2embed() -> _
    -- print('[+] testing msn2 embedding...')

    -- <2> 1?? <2>
    -- <2> True?? <2>
    -- assert(<2>assert(<2>%True%<2>)<2>)
    -- assert(<2> %assert(1)% == True <2>)

    -- @_ = 1

# --------------------------


# ------------------ CLASSES ------------------
~ test_classes() -> _

    -- print('[+] testing classes...')

    # declares a class called 'person' with two attributes
    -- class('person', =>(
        var('name', 'unknown'),
        var('age', -1)
    ))

    # creates an instance of a class
    -- var('joe', person('joe', 20))

    -- assert(exists('joe'))

    # assert vars were set
    -- assert(equals(joe.name(), 'joe'))
    -- assert(equals(joe.age(), 20))

    # set attributes of a class
    -- joe.name('joseph')
    -- joe.age(21)

    # reassert
    -- assert(equals(joe.name(), 'joseph'))
    -- assert(equals(joe.age(), 21))

    # copy of a person
    -- var('joe2', joe.copy())

    # assert that joe2 is a copy of joe
    -- assert(equals(joe2.name(), 'joseph'))
    -- assert(equals(joe2.age(), 21))

    # assert that joe2 is not joe
    -- joe2.name('joe2')
    -- joe2.age(22)

    -- assert(equals(joe2.name(), 'joe2'))
    -- assert(equals(joe2.age(), 22))

    -- assert(not(equals(joe.name(), 'joe2')))
    -- assert(not(equals(joe.age(), 22)))

    # create a family
    -- class('family', =>(
        var('members', [])
    ))

    -- var('fam', family([]))

    -- fam.members(=>(
        var('curr', fam.members()),
        curr.push(?joe?),
        ?curr?
    ))

    -- fam.members(=>(
        var('curr', fam.members()),
        curr.push(?joe2?),
        ?curr?
    ))

    -- assert(equals(?fam?['members'][0]['name'], 'joseph'))
    -- assert(equals(?fam?['members'][0]['age'], 21))
    -- assert(equals(?fam?['members'][1]['name'], 'joe2'))
    -- assert(equals(?fam?['members'][1]['age'], 22))

    -- assert(equals(fam.members(), [?joe?, ?joe2?]))


    # testing classes with methods attached
    -- class ('math', function('_pi', ret('_pi', 3.14)))
    
    # create instance of the class
    -- @ _math = math()

    # assert that function works with no attributes
    -- assert(equals(_math._pi(), 3.14))

    # new class with both attributes and methods
    -- class('math', =>(
        var('pi', 3.1415),
        function('get_pi', ret('get_pi', _math.pi()))
    ))    

    # create instance of the class
    -- @ _math = math()

    # assert that we can get the correct attribute
    -- assert(equals(_math.get_pi(), 3.1415))

    # math class that determines a different value of pi
    -- @_math = math(3.14)

    # assert that the new pi value was changed
    -- assert(equals(_math.pi(), 3.14))





    # larger test
    -- class('box', => (

        # dimensions
        @length=0,
        @width=0,
        @height=0,

        # whats inside?
        @contents=[],

        # box methods
        function ('add_item', =>(
            @ _contents = self.contents(),
            _contents.add(_item),
            _contents
        # class methods should start with 'self'
        ), 'self', '_item'),


        # determines if this box equals another box
        function ('equals', =>(
            # verify all attributes are equal
            ret('equals', and(
                equals(self.length(), _other.length()),
                equals(self.width(), _other.width()),
                equals(self.height(), _other.height()),
                equals(self.contents(), _other.contents())
            ))
        ), 'self', '_other')
    ))

    # create instance of the class
    -- @ _box = box()

    # assert default values
    -- assert(equals(_box.length(), 0))
    -- assert(equals(_box.width(), 0))
    -- assert(equals(_box.height(), 0))
    -- assert(equals(_box.contents(), []))

    # assert that setting attributes works
    -- _box.length(1)
    -- _box.width(2)
    -- _box.height(3)
    -- _box.contents([1, 2, 3])
    -- assert(equals(_box.length(), 1))
    -- assert(equals(_box.width(), 2))
    -- assert(equals(_box.height(), 3))
    -- assert(equals(_box.contents(), [1, 2, 3])) 

    # adding an item to the box
    -- _box.add_item(4)
    -- assert(equals(_box.contents(), [1, 2, 3, 4]))

    # adding a list of [1, 2] to the box
    -- _box.add_item([1, 2])

    # assert that the list was added to the box
    -- assert(equals(_box.contents(), [1, 2, 3, 4, [1, 2]]))

    # creating another box with nothing in it
    -- @ _box2 = box(0, 0, 0, [])

    # make sure the contents are not the same
    -- assert(not(equals(_box.contents(), _box2.contents())))

    # add the contents of _box to _box2
    -- _box2.contents(<<|_box.contents()|.copy()>>)

    # assert their contents are equal
    -- assert(equals(_box.contents(), _box2.contents()))

    # assert all attributes of box2
    -- assert(equals(_box2.length(), 0))
    -- assert(equals(_box2.width(), 0))
    -- assert(equals(_box2.height(), 0))
    -- assert(equals(_box2.contents(), [1, 2, 3, 4, [1, 2]]))

    # reassert the attributes of the original box
    -- assert(equals(_box.length(), 1))
    -- assert(equals(_box.width(), 2))
    -- assert(equals(_box.height(), 3))
    -- assert(equals(_box.contents(), [1, 2, 3, 4, [1, 2]]))

    # assert that box equals itself
    -- assert(_box.equals(_box))
    # assert that box does not equal box2
    -- assert(not(_box.equals(_box2)))

    # modify box2 to have the same dimensions as box
    -- _box2.length(1)
    -- _box2.width(2)
    -- _box2.height(3)

    # assert that box2 now equals box
    -- assert(_box.equals(_box2))

    

    # testing static classes
    -- class ('names', =>(
        @name1="joe",
        @name2="joe2",
        @name3="joe3"
    ))

    # you do not have to create an instance of the class to access its attributes
    -- assert(equals(static(names.name1()), "joe"))
    -- assert(equals(static(names.name2()), "joe2"))
    -- assert(equals(static(names.name3()), "joe3"))

    # you can still create an instance
    -- @ _names = names("mason", "harris", "joe")

    # assert that the instance has the correct attributes
    -- assert(equals(_names.name1(), "mason"))
    -- assert(equals(_names.name2(), "harris"))
    -- assert(equals(_names.name3(), "joe"))

    # reassert the static values are the same
    -- assert(equals(static(names.name1()), "joe"))
    -- assert(equals(static(names.name2()), "joe2"))
    -- assert(equals(static(names.name3()), "joe3"))

    
    # working with class methods and constructors
    -- class('dude', =>(

        # attributes
        @ name = 'unknown',
        @ age = -1,

        # constructor
        function('const', =>(
            self.name(private(=>(
                @_name=self.name(),
                _name.upper()
            )))
        ),'self')

    ))


    # testing
    -- @ dude1 = dude('bruh')
    -- assert(equals(dude1.name(), 'BRUH'))
    -- assert(equals(dude1.age(), -1))



    -- var('_', True)

# -------------------------------------------


# ------------------ COMPLEX STUFF ------------------


~ test_complex() -> _

    -- print('[+] testing complex...')
    -- var('_', assert(
        assert(assert(True), assert(not(False))),
        assert(assert(<< not |False| >>), not(not(True))),
        assert(True and True, assert(True)),
        assert(assert(True), assert(True), assert(=>(
            var('z', -1),
            add('z', 1),
            ?z? == 0
        ))),
        assert(True or False),
        assert(3 != 3 or 5 != 1, [1, 2, 3] == [1, 2, 3]),
        assert(
            True,
            assert(assert(not False), assert(True)),
            assert(True),
            not False,

            # inline function syntax => ()
            # takes any amount of instructions separated by commas
            # can be used in place of any argument or instruction
            # returns the return value of the last instruction to => ()
            => (
                var('map', {'name': 'mason', 'age': 20}),
                ?map?['name'] == 'mason' and ?map?['age'] == 20
            ),
            => (
                var('a', False),
                ?a? or True
            ),

            True,
            assert(True),
            not(not(True))
        ),
        assert(True),
        assert(assert(True), assert(True))))

        -- assert(=>(
            assert(True, True, True, not False, 5 in [5]),
            assert(3 not in {'name': 'joe'}, True, not False, <<|True|>>),
            assert(<<'key' in {'key':4}.keys() >>,
            <<|not(False)|>>,
            <<True>>,
            <<not False>>,
            True,
            not False,
            [{}, {}, {-5238595.34958259283:0}] in [[{}, {}, {-5238595.34958259283:0}], 'hello', -34534.623452345],
            True,
            << isinstance(52348238423.52348234, float) >>,
            << isinstance(-1919191.23287342837423, float) >>,
            << isinstance(5, int) >>,
            << isinstance(-523, int) >>,
            << isinstance([], list) >>,
            << isinstance({}, dict) >>,
            << isinstance('hello', str) >>
            ),
            assert(True, True, 4 == 4, -1214823.52983429 > -34928349823.482),
            assert("mason" in "my name is mason", "hello" in "  wef39i23 hello  "),
            assert(6+3==9,10==10,True,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),
            assert(1, 1, 1, 1, 1, not 0, not(0)),
            assert(True),
            =>(
                True
            ),
            not(False),

            assert(=>(=>(=>(=>(=>(=>(=>(
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
            )))))))),

            =>(assert(True), assert(True), True),
            =>(assert(True, True, assert(assert(True), True))),
            =>(assert(not(exists('foiajweofi')))),
            =>(<<|=>(assert(1, 1))|>>),
            =>(assert(<<1>>), <<0+1-1+1>>),
            =>(
                var('string', '
                    hello, this is a note.

                    [1, 2, 3, 4, 5]   |  | !@#$%^&*())!@#$%^&*()_)(*&^%$#@
                    n\t\n\t\t\\rr\t\\nt\\tr\t\\yn\y\
                '),
                'hello' in ?string? and 
                'this is a note.' in ?string? and
                '[1, 2, 3, 4, 5]' in ?string?
            ),
            1,
            =>(
                not False
            ),
            1,
            1 >= 1,
            'mason'[::-1] == 'nosam',
            ',,,{}][][]{}{}][][][()()()@#$%^&*()'==',,,{}][][]{}{}][][][()()()@#$%^&*()',
            =>(1)
            =>(assert(1, 1, 1, 1, 1, 1))



        ))


    -- var('_', True)


# ------------------ ACTUAL STUFF HAPPENING : THREADS ------------------


# semaphore support
import ('lib/semaphore.msn2')

# tests thread subroutines
~ test_threads() -> _

    -- print('[+] testing threads...')

    -- thread('t1', =>(
        var('count', 0),
        for (0, 10, 'i', =>(
            add('count', 1)
        )),
        assert(?count? == 10)
    ))

    # joins with newly created thread
    -- join('t1')

    # assert count is 10
    -- assert(?count? == 10)

    # testing semaphores
    # main thread grabs the semaphore before the new
    # thread is created
    -- var('sem', semaphore(True, ''))
    -- var('a', 0)

    # creates a new thread
    -- thread('t2', =>(

        # wait for the resource to be unlocked
        wait(not(sem.held())),
        sem.held(True),

        # perform work
        add('a', 1),

        # release the semaphore
        sem.message('finished'),
        sem.held(False)

    ))

    -- assert(sem.held())
    -- assert(equals(sem.message(), ''))

    # give the thread the semaphore
    -- sem.held(False)

    # waits for the thread to write a message to the semaphore
    -- wait(equals(sem.message(), 'finished'))

    # assert the thread released the semaphore
    -- assert(not(sem.held()))

    # assert that the work was finished
    -- assert(?a? == 1)

    # joins threads to avoid thread counting errors
    -- join('t1')
    -- join('t2')

    -- var('_', True)


# -------------------------------------------




# ------------------ ACTUAL STUFF HAPPENING : MULTIPROCESSING ------------------

# multiprocessing support
import ('lib/processes.msn2')

# MSNScript2 is capable of multiprocessing, follow the documentation below
~ test_processes() -> _ 

    -- print('[+] testing processes...')

    # creates a new process
    # second argument to fork() must be async() to save
    # the block of code for use by the newly created process
    -- fork('process1', async(=>(

        # process performs work
        var('forkvar', 0),
        assert(exists('forkvar')),
        for (0, 10, 'i', =>(
            add('forkvar', 1)
        )),
        assert(?forkvar? == 10)
    )))

    # joins with the process
    # same syntax as threads because fork() is a user method imported from lib/processes.msn2
    # thats starts the process from a new thread
    -- join('process1')
    
    -- assert(not(exists('forkvar')))

    # test 2
    -- var('a', 0)

    # starts two processes that perform work
    -- for(0, 2, 'i', =>(
        fork(?i?, async(=>(

            print('[+] testing process', cat(?i?, '...')),

            # process specific variables
            var('a', 0),
            var('b', 0),
            var('c', 0),
            assert(exists('a'), exists('b'), exists('c')),

            # if process 0
            if (?i? == 0, =>(

                # assert the variables exists
                assert(exists('a'), exists('b'), exists('c')),
                assert(not(exists('d')), not(exists('e')), not(exists('f'))),



                # modify the variables
                add('a', 1),
                add('b', 1),
                add('c', 1),

                # assert the variables were modified
                assert(?a? == 1, ?b? == 1, ?c? == 1),

            ), 

            # else if process 1
            =>(
                # same as 0
                assert(exists('a'), exists('b'), exists('c')),
                assert(not(exists('d')), not(exists('e')), not(exists('f'))),
                add('a', 10),
                add('b', 10),
                add('c', 10),
                assert(?a? == 10, ?b? == 10, ?c? == 10),
            ))
        )))
    ))

    # joins with the first process created
    -- join(0)

    -- var('_', True)
# -------------------------------------------




# ------------------ ACTUAL STUFF HAPPENING : ENDPOINTS ------------------

var('terminate', False)


# hosting an endpoint
~ test_endpoints() -> _

    -- print ('[+] testing endpoints')

    # endpoints should reside in a new process
    -- fork('ep1', async(=>(
        
        # starts a new endpoint on localhost:5000 on a new thread
        thread('t', ENDPOINT('127.0.0.1', 5000, '/', {})),

        # waits for a signal to end the process, with a 0.05s interval
        wait(equals(GET('127.0.0.1', 5000, '/'), {'leave': 1}), sleep(0.5)),

        # stops the forked process
        stop()
    )))
    
    # wait for endpoint to become active
    -- wait(equals(GET('127.0.0.1', 5000, '/'), {}), sleep(0.5))

    # assert endpoint is responsive
    -- assert(equals(GET('127.0.0.1', 5000, '/'), {}))

    # asserts post is working
    -- assert(equals(POST('127.0.0.1', 5000, '/', {'a': 1}), {'a': 1}))

    # asserts get is working
    -- assert(equals(GET('127.0.0.1', 5000, '/'), {'a': 1}))

    # asserts deletion is working
    -- assert(equals(DELETE('127.0.0.1', 5000, '/'), {}))

    # stops the endpoint's host process
    -- assert(equals(POST('127.0.0.1', 5000, '/', {'leave': 1}), {'leave': 1}))

    # this should be the last test listed, 
    # and the last test to finish, 
    # so stop() ends the validator program
    -- print('[+] shutting down validator and endpoint...')

    # ends the timer and prints finishing boot environment
    -- print('[+] fin in', cat(timer_runtime(), 's'))

    # imports clean_processes()
    -- import('lib/processes.msn2')

    # cleans processes
    -- clean_processes()

    -- add_threads()

    # includes the thread that launched the endpoints tests
    -- add('thread_count', 1)

    # prints accounting information
    -- print_threads()

    # stops the program, as server endpoints can only be 
    -- stop()

# -------------------------------------------




# ------------------ RANDOMNESS ------------------

# random implementation includes
# a single system call 'random()'
~ test_random() -> _

    -- print('[+] testing random...')

    # runs tests multiple times for random function
    -- for (0, 100, 'i', =>(

        # random() with 0-1 arguments returns a float between
        # 0-1
        var('r', random()),
        assert(?r? < 1 and ?r? >= 0),

        # random() with 2 arguments returns a range between the
        # two values passed
        var('r2', random(1, 2)),
        assert(?r2? < 3 and ?r2? >= 1),

        var('r3', random(0, 100)),
        assert(?r3? < 100 and ?r3? >= 0),

        # a random() with 3 arguments
        # defaults the return value to an integer,
        # effectively implementing float and integer random
        # capabilities from random()
        var('r4', random(0, 100, <<>>)),

        # asserts the value is an integer with python fallback
        assert(<< isinstance(|?r4?|, int) >>),
        assert(?r4? < 100 and ?r4? >= 0),

        # creates an array of random values with python fallback
        var('r5', <<[|random()|,|random(0, 10)|,|random(0, 10, '')|]>>),

        # assert type of random
        assert(<< isinstance(|?r5?[0]|, float) >>, not(<< isinstance(|?r5?[0]|, int) >>)),
        assert(<< isinstance(|?r5?[1]|, float) >>, not(<< isinstance(|?r5?[1]|, int) >>)),
        assert(<< isinstance(|?r5?[2]|, int) >>, not(<< isinstance(|?r5?[2]|, float) >>)),

        # assert range of random
        assert(?r5?[0] < 1 and ?r5?[0] >= 0),
        assert(?r5?[1] < 10 and ?r5?[1] >= 0),
        assert(?r5?[2] < 10 and ?r5?[2] >= 0)
    ))

    -- var('_', True)
    
# -------------------------------------------





# ------------------ SIMPLE LOOPS ------------------



# simple loops are written as functions with the below syntax
# two integers, and an index variable before the loop's block arguments within the ()
# the arguments to the simple loop between the || cannot be anything but an integer

# 6/3/2023: added an integer as a syscall, running its block that many times
# this works for any integer

# tests another loop approach
~ test_simple_loops() -> _

    -- print('[+] testing simple loops...')

    -- @ a = 0

    # simple loop syntax
    -- 0|2|i (add('a', 1))

    -- assert(?a? == 2)

    -- @ a = 0
    --0|5|i(add('a', ?i?))
    -- assert(?a? == 10)

    -- @ a = 0
    -- 0 | 3 | i (add('a', 1))
    -- assert(?a? == 3)

    # brute test
    --@a=0
    --     5    |   2 |_(add(   'a', 1))
    -- assert(1 , ?a? == 3)
    
    --@a=0

    # nested simple loops
    -- 2 | 6 | i    (1|4|j  (add('a', 1)))
    -- assert(?a? == 12)


    # testing integer syscall
    -- @ a = 0
    -- 5 (add('a', 1))
    -- assert(a.equals(5))

    -- @ a = 0
    -- 300(a.add(1))
    -- assert(a.equals(300))





    # uses msn1 fallback to simplify returning process, see returning tests for returning requirements
    -- @ _ = 1

# -------------------------------------------

# ------------------ SIMPLE CONDITIONALS ------------------

# simpler conditional implementation
# ? syntax is a function, meaning it requires (true_block, false_block) for a block to execute
# the argument to ? cannot be a function itself
~ test_simple_cond() -> _
    -- print('[+] testing simple cond...')
    
    # assert syntax is functional
    -- ? True (assert(True), assert(False))
    -- ? False (assert(False), assert(True))

    # slightly more advanced variations
    -- @ a = 1
    -- ? ?a? (assert(True), assert(False))
    -- ? not ?a? (assert(False))

    # no () can exist between ? and its blocks in ()
    # --v----------------v
    -- ? 0 (assert(False), assert(True))

    -- ? 0 (assert(False))
    -- @_=1

# -------------------------------------------

# ------------------ DEFINING SYNTAX ------------------

# the system call syntax() is used to define new syntax
# syntax() takes three arguments
# the created syntax will exist in all contexts across all threads
# 
# it is safe and highly recommended to choose unique tokens to avoid symbolic / naming conflicts within 
# base MSNScript2 syntax
#
# first argument indicates the token surrounding a block of text in an MSNScript2 argument, this block of text
# does not need to conform to MSNScript2 / Python syntax
#
# second argument stores the internals surrounded by the token specified
# as the first argument
#
# third argument is what should be returned according to the line confined within the new token
#
~ test_user_syntax() -> _
    
    -- print('[+] testing user syntax...')

    # defines a new syntax for the '!!!' token
    -- syntax('!!!', 'line', =>(
        assert(exists('line')),
        assert(?line? == ' 5 + 2 - 6 * 2 '),
        assert(<< |eval(?line?)| == -5 >>),
    ))

    # demonstrating the syntax
    -- !!! 5 + 2 - 6 * 2 !!!

    # creating a new syntax
    -- syntax('goof', 'line', =>(
        @ a = 1000,
        1
    ))

    # asserting syntax
    -- assert(goofgoof, exists('a'), ?a? == 1000)
    -- assert(goof, goofgoof, =>(goof))


    # more practical implementations

    # defines and writes to a single local storage by which programs can communicate
    -- syntax('LOCAL', 'line', =>(
        file.mkdir('localstorage'),
        file.create('localstorage/local.txt'),
        file.write('localstorage/local.txt', ?line?),
        file.read('localstorage/local.txt')
    ))

    # asserts the write was correct
    -- assert(<< |LOCAL 5729348570234 LOCAL| == ' 5729348570234 ' >>)
    -- assert(<< |LOCAL hello! LOCAL| == ' hello! ' >>)
    -- assert(<< |LOCAL this is some text LOCAL| == ' this is some text ' >>)

    # more advanced syntax
    # creates an array out of all things surrounded by '---'
    # when inside the user defined context
    -- syntax('$', 'line', =>(
        var('____', []),
        var('insides', between('-', ?line?)),
        each(?insides?, 'line2', =>(
            ____.push(?line2?)
        )),
        ?____? 
    ))

    # create quicker assertion syntax
    -- syntax('!!', 'line', =>(
        each(split(?line?, '--'), 'line2', =>(
            if(not(-(?line2?)), print('[-] assertion failed: ' + ?line?)),
        ))
    ))

    # demonstrating new syntax
    -- .. !! -- True -- 1 -- [1, 2, 3, 4] == [1, 2, 3, 4] -- assert(assert(True)) !!

    # using =>() to invoke multiline interpretation
    -- =>(
        !!
        True
        --
        True
        --
        # we use th previous syntax to form an array
        equals($ -1- -2- -9- $, ['1', '2', '9'])
        !!
    )

    # we use the new syntax to define an array of strings,
    # we then return this array to the python fallback mechanism (<<>>)
    # where we rely on Python to perform list comprehension to bring the integers
    # out of each string element
    -- assert(equals(var('array', << [int(i) for i in |$ -1- -2- -3- -4- -5- $|] >>), [1, 2, 3, 4, 5]))
    -- assert(?array? == [1, 2, 3, 4, 5])
    # demonstrates the new syntax
    -- var('array', $$ -5- -3- -0-   $$)
    -- var('array', << [int(i) for i in |?array?|] >>)
    -- assert(?array? == [5, 3, 0])    

    
    # pretend global variable
    -- @ a = 0

    # defines a new syntax to make an increment of a variable easier
    -- syntax('++', 'line', =>(
        @ a += 1
    ))

    # assert functionality
    -- assert(?a? == 0)
    -- ++
    -- assert(?a? == 1)
    -- 0|10|_(++)
    -- assert(?a? == 11)
    -- ? True (=>(++, =>(
        0|5|_ (++)
    )))
    -- assert(?a? == 17)
    
    # paired user syntax tags still act as a single call to that syntax
    -- =>(
        ++
        ++
    )

    -- assert(?a? == 18)
    
    -- @ _ = 1
# -------------------------------------------

# ------------------ COMPLEX 2 ------------------

~ test_complex2() -> _

    -- print('[+] testing complex 2...')


    -- @ _ = 1


# -------------------------------------------

# ------------------ TESTS MACROS ------------------

# imports serialization for thread naming
import('lib/serial.msn2')

# opens a new serialization variable
serial_open('thread')

# MSNScript2 has both the ability to create new syntax as well as new macros
#
# macros are similar to syntax, however they are confined to a single line.
# any text after the macro will be passed to the macro function,
# where the user should handle the return value
#
# macro arguments should be literals in most cases
~ test_macros() -> _

    -- print('[+] testing macros...')

    # defines a new macro to create a thread, returning its name
    # any line of code preceeded with a ':' will 
    # be executed on a new thread
    -- macro(':', 'line', =>(
        @ name = |serial_next('thread')|,
        thread(?name?, -(?line?)),
        ?name?
    ))

    # demonstrates the new macro
    -- : assert(True, 1, not(False))
    
    # creates a thread on a new context that runs an assertion
    -- : new(=>(
        assert(not(exists('a')), not(exists('b')), not(exists('c'))),
        assert(True, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
    ))

    # macros working together
    # creating subthread
    -- : : =>(
        @ v = 3,
        assert(exists('v'), ?v? == 3),
    )

    # quicker assertion
    -- macro('!', 'line', assert(-(?line?)))

    -- =>(! True, !not(False))

    -- ! not False

    # creates a few threads that make some assertions
    -- : : : =>(!True, !1, !not 0)


    -- @ _ = 1
# -------------------------------------------

# ------------------ TESTS POSTMACROS ------------------

# tests the concept of postmacros, which in turn create a new syntax that should exist
# at the end of any single line of code
# when a line is succeeded by a postmacro token, a function
# will be invoked on the line preceeding the postmacro
# this function is defined by the user
# 
# similarly to macros, if a 4th argument is added, the third
# argument as a function is ignored and a value is returned instead
~ test_postmacros()->_
    
    -- print('[+] testing postmacros...')

    # creates a post macro for a more English approach to asserting
    # i guess you could call it questioning lol
    -- postmacro('??', 'line', =>(
        if (not(-(line)), print(
            '[-] assertion error : ', line
        ))
    ))

    # demonstrates the postmacro
    -- True??
    -- not False and True ??
    -- assert(True, 1, 1)??

    # 4th argument added
    -- postmacro('_PI_', '__unused', None, 3.14)
    -- assert(equals(_PI_, 3.14), not(equals(5.123, _PI_)))
    
    # floors a number
    -- postmacro('VVV', '__expression', =>(
       math.floor(-(?__expression?))
    ))

    # ceils a number
    -- postmacro('^^^', '__expression', =>(
        math.ceil(-(?__expression?))
    ))

    # divides a number by 2
    -- postmacro('BY2', '__expression', =>(
        << |-(?__expression?)| / 2 >>
    ))

    -- assert(equals(3, 3.438732 VVV))
    -- assert(.438275^^^)
    -- assert(1.43254394382743928VVV)

    -- assert(equals(4 BY2, 2), 2 BY2)

    # postmacros can be chained, similarly to macros
    -- assert(equals(4 BY2 BY2, 1))

    # using multiple postmacros
    # divides by 2, then floors
    -- assert(equals(9 BY2 VVV, 4))
    -- assert(equals(6.234^^^ BY2 VVV, 3))

    -- @ _ = 1
# -------------------------------------------

# ------------------ TESTS ENCLOSING SYNTAX ------------------

# tests integrity of an enclosing syntax
~ test_enclosing() -> _

    -- print('[+] testing enclosing syntax...')

    # creates an enclosing macro surrounded by the start and end token,
    # invoked by preceeding a line with a '(', similarly to the previous
    # macro, postmacro, and syntax definitions

    # SAFELY extracts a variable's value
    -- enclosedsyntax('^', '^', '__line', val(val('__line')))

    -- @v = 'hello\n how are you?'

    -- assert(equals(^v^, 'hello\n how are you?'))


    -- @ _ = 1

# -------------------------------------------

# ------------------ TESTS ENCLOSING SYNTAX ------------------

# destroy() system call destroys variables or user defined functions (~)
~ test_destroy() -> _

    -- print('[+] testing destroy...')

    -- @v = 1

    -- assert(exists('v'))

    -- destroy('v')

    -- assert(not(exists('v')))

    -- @ _ = 1
# -------------------------------------------

# ------------------ TESTS HTML ------------------

# tests html functions
~ test_html()->_
    -- print('[+] testing html...')

    -- @_=1

# -------------------------------------------

# ------------------ TESTS FUNCTION() SYSTEM CALL ------------------

# tests function()
# implementing function() is an attempt to offer a fully stable way
# of declaring user methods
# 
# function() is a simply a better alternative to '~'
# the context rules still apply to these functions the same way as '~'
~ test_function()->_

    -- print('[+] testing functions...')

    # creating a new user function
    # ret() returns to a function()
    # these two system calls work hand in hand
    
    # this creates a user function called array_sum() that takes an array,
    # which is used in the function's context to compute its sum
    -- function('array_sum', ret('array_sum', sum(^__array^)), '__array')
    
    # invoking the function is the same
    -- equals(private(array_sum([1, 2, 3, 4, 5])), 15) ??

    # you can overwrite a function be redeclaring it
    -- function('array_sum', ret('array_sum', 0), '__array')

    -- equals(private(array_sum(None)), 0) ??



    # playing with functions
    -- function('f', ret('f', _e), '_e')

    # running the already declared function
    -- equals(private(f(5)), 5) ??

    # NOTE : function()'s first argument should be a hard coded string
    # avoid not using a hard coded string when creating class() inner methods

    -- @ _ = 1

# -------------------------------------------

# ------------------ TESTS INTERPRETER REDIRECTION ------------------

# interpreter redirection allows for lines of code to be redirected to a 2REDIRECT
# and 2STOPREDIRECT  system calls that alter the path of the working 
# interpreter to a function that would operate on the line instead
# this will occur until 2STOPREDIRECT is called
# the lines surrounded by the REDIRECT keywords can all be invoked via '2STARTREDIRECT'
# 
# usage:
# 2REDIRECT line_variable_name 2TO block
# ****
# ****
# ****
# 2STOPREDIRECT
# 2STARTREDIRECT

# using a different function declaration syntax just as demonstration
function('test_redirect', =>(

    print('[+] testing redirect...'),

    # for each instruction until stopredirect, perform an instruction

    # creates redirect that increases a variable name by 1

    @v = 1,
    @v2 = 2,
    redirect('__line', add(val('__line'), 1)),
    v,
    v2,
    v2,
    stopredirect(),

    # launches the code inside the redirect
    startredirect(),
    equals(^v^, 2) ??,
    equals(^v2^, 4) ??,


    # creates another redirect that simply evaluates each instruction in between
    redirect('__line', -(val('__line'))),
        5 == 5 ??,
        34 > 1 ??,
    stopredirect(),

    # launch the code inside the redirect
    startredirect(),


    ret('test_redirect', 1)
))

# -------------------------------------------

# ------------------ TESTS INTERPRETER REDIRECTION ------------------
~ test_userfunc_with_args() -> _
    
    -- print('[+] testing userfunc with args...')
    
    # declaring a user defined function
    -- function('__test', ret('__test', =>(
        assert(exists('__arg1')),
        assert(exists('__arg2')),
        assert(equals(val('__arg1'), 1)),
        assert(equals(val('__arg2'), 2)),
    )), '__arg1', '__arg2')

    # running method privately
    -- private(__test(1, 2))


    # also testing nested user functions
    -- function('__test2', ret('__test2', =>(
        assert(exists('__arg1')),
        assert(exists('__arg2')),
        assert(equals(val('__arg1'), 3)),
        assert(equals(val('__arg2'), 4)),

        # we use private() to prevent variable leakage to other contexts that need the same
        # variable names
        private(__test(1, 2)),
        assert(equals(val('__arg1'), 3)),
        assert(equals(val('__arg2'), 4)),
    )), '__arg1', '__arg2')

    # running test privately
    -- private(__test2(3, 4))

    -- @ _ = 1

# -------------------------------------------

# ------------------ TESTING OP CLASS ------------------

# tests the built in op class, used for general functional operations on all types
# the op class simply performs operations, and does not modify any variables or methods
#
# a benefit of using the op class is the fact that there are many method names that
# perform the same operation, allowing the programming to forget the specific syntax to focus on other problems
#
# every method in the op class takes any amount of arguments, and returns the result of the operation
~ test_op() -> _

    -- print('[+] testing op class...')

    -- @v = 1

    # testing add on numbers
    -- assert(equals(op.add(?v?, 4), 5))

    # testing different names for the same operation
    -- assert(equals(op.add(?v?, 4), op.plus(?v?, 4)))
    -- assert(equals(op.add(?v?, 4), op.sum(?v?, 4)))
    -- assert(equals(op.add(?v?, 4), op.+(?v?, 4)))


    # testing add on strings
    -- assert(equals(op.add(str(?v?), '4'), '14'))
    -- assert(equals(op.add(str(?v?), '4'), op.plus(str(?v?), '4')))
    -- assert(equals(op.add(str(?v?), '4'), op.sum(str(?v?), '4')))
    -- assert(equals(op.add(str(?v?), '4'), op.+(str(?v?), '4')))
    -- assert(equals(op.add(str(?v?), '4'), op.concat(str(?v?), '4')))

    # testing add on lists
    -- assert(equals(op.add([5], 4, 3), [5, 4, 3]))
    -- assert(equals(op.add([5], 4, 3), op.plus([5], 4, 3)))
    -- assert(equals(op.add([5], 4, 3), op.sum([5], 4, 3)))

    # testing recommended choice of method name for all other operations
    -- assert(equals(op.sub(?v?, 4), -3))
    -- assert(equals(op.mul(?v?, 4), 4))
    -- assert(equals(op.div(?v?, 4), 0.25))
    -- assert(equals(op.mod(?v?, 4), 1))
    -- assert(equals(op.pow(?v?, 4), 1))

    # testing with any amount of arguments
    -- assert(equals(op.add(1, 2, 3, 4, 5), 15))
    -- assert(equals(op.add(1, 2, 3, 4, 5), op.plus(1, 2, 3, 4, 5)))

    # testing sub with any amount of arguments
    -- assert(equals(op.sub(1, 2, 3, 4, 5), -13))
    -- assert(equals(op.sub(1, 2, 3, 4, 5), op.minus(1, 2, 3, 4, 5)))

    # testing mul with any amount of arguments
    -- assert(equals(op.mul(1, 2, 3, 4, 5), 120))
    -- assert(equals(op.mul(1, 2, 3, 4, 5), op.times(1, 2, 3, 4, 5)))

    # testing div with any amount of arguments that results in a whole number
    -- assert(equals(op.div(16, 2, 2, 2), 2))
    -- assert(equals(op.div(16, 2, 2, 2), op.divide(16, 2, 2, 2)))

    # testing div with any amount of arguments that results in a decimal
    -- assert(equals(op.div(16, 3, 2, 2), 1.3333333333333333))
    -- assert(equals(op.div(16, 3, 2, 2), op.divide(16, 3, 2, 2)))

    # testing mod with any amount of arguments that results in 1
    -- assert(equals(op.mod(16, 3, 2, 2), 1))

    # testing pow with any amount of arguments
    -- assert(equals(op.pow(2, 2, 2), 16))

    -- @_ = 1

# -------------------------------------------

# ------------------ TESTING ALL TYPE METHODS ------------------

# all types share certain methods, this test demonstrates those methods
# certain methods cannot and should not be used on certain types
# ex: integer.copy() will not work and should not be
# used (integer), however array.copy() will
~ test_global_methods() -> _ 

    -- print('[+] testing global methods...')

    -- @v = [1, 2, 3, 4]

    # testing copy()
    -- @v2 = v.copy()
    -- equals(v, v2) ??

    # testing len()
    -- equals(v.len(), 4) ??

    # testing val()
    -- equals(v, [1, 2, 3, 4]) ??

    # test casting methods
    -- equals(v.str(), '[1, 2, 3, 4]') ??

    -- @ string = 'hello world'

    # calling str() is like calling str(string) and is essentially the same as calling string
    # with extra, unnecessary steps
    -- equals(string.str(), 'hello world') ??

    -- @ string = '[3, 4, 5, 65]'

    # testing -() explicitly
    # interprets msn2 code as a string
    -- equals(-(string), [3, 4, 5, 65]) ??

    # finally, an equals method for all types
    # equals(), like the system call, takes any amount of arguments
    -- string.equals('[3, 4, 5, 65]') ??

    # extract the value from the string
    -- @ array = -(string)

    # lists, like all other types, have an equals method
    -- array.equals([3, 4, 5, 65]) ??

    # test with floats
    -- @ float = 45.432
    -- equals(float.str(), '45.432') ??

    -- float.equals(45.432) ??

    # test with dictionaries
    -- @ dict = { 'a': 1, 'b': 2, 'c': 3 }
    -- equals(dict.str(), "{'a': 1, 'b': 2, 'c': 3}") ??

    -- dict.equals({ 'a': 1, 'b': 2, 'c': 3 }, dictfrom('a', 1, 'b', 2, 'c', 3)) ??

    -- @_ = 1
# -------------------------------------------

# ------------------ TESTING INTEGER METHODS ------------------
~ test_int_methods() -> _

    -- print('[+] testing integer methods...')

    -- @ int = 5
    -- @ int2 = 10

    # testing increment
    -- int.inc()
    -- equals(int, 6) ??

    # testing decrement
    -- int.dec()
    -- equals(int, 5) ??

    # testing add
    -- equals(int.add(int2), 15) ??
    
    -- @int = 0

    -- @integer = 0

    # testing add with any amount of arguments
    -- equals(integer.add(1, 2, 3, 4, 5), 15) ??

    # number comparison methods
    
    -- integer.equals(15) ??

    # testing a dictionary
    -- @ dictionary = {}
    -- dictionary.equals({}) ??
    -- not(dictionary.equals({ 'a': 1 })) ??

    # test greater and its aliases, greaterthan and g
    -- integer.greater(14) ??
    -- not(integer.greater(15)) ??

    -- integer.greaterthan(14) ??
    -- not(integer.greaterthan(15)) ??

    -- integer.g(14) ??
    -- not(integer.g(15)) ??

    # test less and its aliases, lessthan and l
    -- integer.less(16) ??
    -- not(integer.less(15)) ??

    -- integer.lessthan(16) ??
    -- not(integer.lessthan(15)) ??

    -- integer.l(16) ??
    -- not(integer.l(15)) ??

    # test greater or equal and its aliases, greaterequal and ge
    -- integer.greaterequal(15) ??
    -- not(integer.greaterequal(16)) ??

    -- integer.ge(15) ??
    -- not(integer.ge(16)) ??

    # test less or equal and its aliases, lessequal and le
    -- integer.lessequal(15) ??
    -- not(integer.lessequal(14)) ??

    -- integer.le(15) ??
    -- not(integer.le(14)) ??

    # testing comparisons with many arguments

    -- integer.greater(11, 12, 13, 14) ??
    -- not(integer.greater(11, 12, 13, 14, 15)) ??

    -- integer.greaterthan(11, 12, 13, 14) ??
    -- not(integer.greaterthan(11, 12, 13, 14, 15)) ??

    -- integer.g(11, 12, 13, 14) ??
    -- not(integer.g(11, 12, 13, 14, 15)) ??

    # tests extra dictionary methods

    -- @ dict = { 'a': 1, 'b': 2, 'c': 3 }

    -- equals(list(dict.keys()), ['a', 'b', 'c']) ??
    
    -- equals(list(dict.values()), [1, 2, 3]) ??

    -- @ _ = 1
# -------------------------------------------


# ------------------ TESTING GLOBAL METHODS ------------------
~ test_more_global_methods() -> _

    -- print('[+] testing more global methods...')

    # testing each 

    -- @ sum = 0

    -- @ v = [1, 2, 3, 4]
    -- v.each('e', sum.add(e))
    -- sum.equals(10) ??


    # obtaining a slice
    -- @ slice = v.slice(0, 2)
    -- slice.equals([1, 2]) ??

    # obtaining a slice of a string
    -- @ string = 'hello world'
    -- @ slice = string.slice(0, 5)
    -- slice.equals('hello') ??


    # testing map
    -- @ v = [5, 4, 3, 2, 1]
    -- v.map('el', el.add(1))
    -- v.equals([6, 5, 4, 3, 2]) ??

    # testing map with a dictionary
    -- @ dict = { 'a': 1, 'b': 2, 'c': 3 }

    # the map function on a dictionary can prove to be powerful
    # for each iteration of map(), the key and value pair are set to a variable
    # the key and value pair can be accessed by the variables 'k' and 'v'
    # the values of temporary variables 'k' and 'v' can be changed in the function
    # the values of the dictionary are changed to the values of the temporary variables

    # does nothing to 'k' and 'v'
    -- dict.map('k', 'v', =>())
    -- dict.equals({ 'a': 1, 'b': 2, 'c': 3 })??

    # increases the value by 1
    -- dict.map('k', 'v', v.inc())
    -- dict.equals({ 'a': 2, 'b': 3, 'c': 4 })??

    # changes both the key and the value
    -- dict.map('k', 'v', =>(
        @ k = 'd',
        @ v = 5
    ))

    -- dict.equals({ 'd': 5 }) ??


    # testing setting of string character
    -- @ string = 'hello world'
    -- string.set(0, 'H')
    -- string.equals('Hello world') ??

    # reversing a string
    -- string.reverse()
    -- string.equals('dlrow olleH') ??
    -- not(string.equals('Hello world')) ??

    # reversing an array
    -- @ v = [1, 2, 3, 4, 5]
    -- v.reverse()
    -- v.equals([5, 4, 3, 2, 1]) ??
    -- not(v.equals([]))

    # indexing an iterable faster
    -- @v = {'hello': {'key': {'key2': 'password'}}}

    # use -> to continue indexing after '.'
    -- equals(v.hello -> key->key2(), 'password') ??

    # add an argument to invoke a setting method
    # instead of a getting method
    # returns what was set
    -- equals(v.hello->key ->key2('new_password'), 'new_password') ??
    -- equals(v. hello -> key-> key2(), 'new_password') ??

    # -> should not be used with lists, use .get() instead


    -- @ _ = 1
# -------------------------------------------



# ------------------ '() -->' macro ------------------

# the '() -->' macro allows for a repetitive function call on a variable
# the '() -->' macro ONLY works with DESTRUCTIVE methods,
# as its purpose is to repetitively alter a variable
~ test_paren_macro() -> _

    -- print('[+] testing () built in macro...')

    # testing '() then' containedmacro
    -- @ v = 1

    # calls these variable methods in sequence
    # basically does v.add(1).add(2).sub(1)
    -- () v.add(1)-->add(2)-->sub(1) 
    -- v.equals(3) ??


    # testing on a string
    -- @ string = 'hello!'
    -- () string.upper() --> reverse()
    -- string.equals('!OLLEH') ??

    # testing on a list
    -- @ v = [1, 2, 3, 4, 5]
    -- () v.append(6) -->  reverse()
    -- v.equals([6, 5, 4, 3, 2, 1]) ??


    # testing on a dictionary
    -- @ dict = { 'a': 1, 'b': 2, 'c': 3 }
    -- () dict.set('d', 4) --> set('e', 5)
    -- dict.equals({ 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }) ??

    # obtaining its return value
    -- @ bro = @bro2 = @bro3 = 10
    -- equals(()bro .++() --> ++() --> ++(), 13) ??
    -- bro.equals(13) ??
    -- bro2.equals(10) ??
    -- bro3.equals(10) ??

    # testing on a float
    -- @ float = -3.5

    # 3.5 --> 3 --> 3 --> -3
    -- () float.abs() --> floor() --> ceil() --> neg()
    -- float.equals(-3) ??

    # testing again on a string
    -- @ string = 'Hello, World!'
    -- () string.cut (0, 5) --> upper() --> reverse()
    -- string.equals('OLLEH') ??

    -- @ _ = 1

# -------------------------------------------



# ------------------ TESTING RANDOM STUFF ------------------

# this is a test that implements some random things
~ test_other_stuff() -> _

    -- print('[+] testing other stuff...')

    # directly utilizing Python's imports
    # pre-imported math class
    -- @ v1 = @v2 = <<math.ceil(|3 + 0.5|)>>
    -- and(v1.equals(4), v2.equals(4)) ??

    # messing around with <2><2>
    -- assert(<2>%1%<2>)
    -- assert(<2>%not(0)%<2>)

    -- assert(
        <2>
            %assert(1)% == %1%
        <2>
    )

    # reversing an array again
    -- @ a = [1, 2, 3, 4, 5]
    -- equals(a.reverse(), [5, 4, 3, 2, 1 ]) ??

    # simple array operations
    -- a.add(a.get(2))
    -- a.equals([5, 4, 3, 2, 1, 3]) ??

    # sorting an array by evens, then odds
    -- function('_reset', =>(a.equals([2, 4, 6, 1, 3, 5]) ??, @ a = [1, 2, 3, 4, 5, 6]))
    -- @ a = [1, 2, 3, 4, 5, 6]

    -- @ a = =>(
        << [el for el in |a| if el % 2 == 0] + 
           [el for el in |a| if el % 2 != 0] >>)
    
    # assert correction and reset 'a'
    -- _reset()

    # calculating factorial, recursively
    -- function('factorial', ret('factorial', =>(
        if (equals(n, 0), 1, op.times(n, factorial(op.sub(n, 1))))
    )), 'n')

    # testing factorial in a private context
    -- equals(private(factorial(0)), 1) ??
    -- equals(private(factorial(1)), 1) ??
    -- equals(private(factorial(2)), 2) ??
    -- equals(private(factorial(3)), 6) ??
    -- equals(private(factorial(4)), 24) ??
    -- equals(private(factorial(5)), 120) ??
    -- equals(private(factorial(6)), 720) ??


    # lol
    -- if(1,if(1,if(1,assert(1))))

    # entering a private context
    -- new(=>(
        class('range', @all=list(range(0,10))),
        # assert two class insantces have the same initial attribute
        equals(->(range(), 'all'), ->(range(), 'all'))
    ))

    # private function
    -- function('priv', =>(
        # import english alphabet
        import('lib/eng.msn2'),
        @ _i = 0,
        # create a variable for each letter of the alphabet
        english_alphabet.each('letter', =>(
            var(letter.val(), _i.inc())
        )),
        ret('priv', z)
    ))
    -- assert(equals(private(priv()), 26))
    
    # classes working together
    -- new(=>(
        # making a class of tests
        class('random_tests', =>(
            # test 1
            function('test1', =>(
                assert(equals(op.add(value, 3), 13))
            ), 'self', 'value')
        )),
        =>(@_r=random_tests(),_r.test1(10))
    ))

    # testing the 'in' operator
    -- @ v = 4
    -- assert(v.in([1, 2, 3, 4, 5]))
    -- assert(not(v.in([1, 2, 3, 5, 6])))
    -- assert(v.in([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))    

    # removes duplicates from an array
    -- function(@_nd="remove_dups", ret((_nd), list(_array.toset())), '_array')

    -- equals(remove_dups([1, 2, 3, 4, 5, 5, 4, 3, 2, 1]), [1, 2, 3, 4, 5]) ??
    # another test
    -- equals(remove_dups(
        [1, 2, 3, 4, 5, 5, 4, 3, 2, 1, 6, 7, 8, 9, 10]
    ), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ??
    
    




    -- @ _ = 1






# -------------------------------------------


# ------------------ TESTING SUBCLASSES ------------------

# tests nested classes
# using function() just to verify integrity
function('subclasses', =>(

    # testing subclasses
    print('[+] testing subclasses...'),

    # declaring a class
    class ('_test', =>(
        # class functions
        function('get', ret('get',-1), 'self'),
        function('get2', ret('get2',1), 'self'),
        
        # subclass
        class('_test_sub', =>(
            @att=5, 
            function('get_att', ret('get_att', self.att()), 'self')
        )),

        # creating an instance of the subclass
        @sub = _test_sub(),
        # asserting the class was created correctly
        assert(equals(sub.att(), 5, sub.get_att())),
    )),

    # creating an instance of the class
    @test = _test(),

    # instance of the subclass
    @sub = test.sub(),

    # verifying you can access the subclass and create
    # instances of it
    assert(equals(sub.get_att(), 5, sub.att())),

    # return
    ret('subclasses', 1)
))



# -------------------------------------------

# ------------------ TESTING JOINT MACROS ------------------
# tests defined macros being used together
# import msn2plus
import('lib/syntax/msn2plus.msn2')


# new, safer function declaration mechanism
function('jointmacros', =>(
    print('[+] testing joint macros...'),

    and(1, 1) ??,
    or(0, 1) ??,
    and(or(1, 0),or(1, 1),or(0, 1)) ??,
    and(=>(1), =>(1)) ??,
    ret('jointmacros', 1)
))

# -------------------------------------------

# ------------------ TESTING SETS ------------------
function('test_sets', =>(
    print('[+] testing sets...'),

    # creating an empty set
    @ set = set(),

    # length of set should be zero
    not(set.len()) ??,

    # add a bunch of things to the set
    set.add(1, 2, 3, 4, 5, 5, 4, 3, 2, 1),

    # length of set should be 5
    equals(set.len(), 5) ??,

    # asserts what the set is
    equals(set, {1, 2, 3, 4, 5}) ??,

    # asserts the set can be cast to a list
    equals(set.list(), [1, 2, 3, 4, 5]) ??,

    # gets an an index in the set
    equals(set.get(0), 1) ??,
    equals(set.get(1), 2) ??,
    equals(set.get(2), 3) ??,
    equals(set.get(3), 4) ??,
    equals(set.get(4), 5) ??,

    # assert set equals again
    set.equals({1, 2, 3, 4, 5}) ??,

    # creating a set from a constructor
    @ set = set(0, 1, 2, 3),

    # assert set equals
    set.equals({0, 1, 2, 3}) ??,



    # set inside a class
    class('test_set', =>(

        # set attributes
        @ set = set(0, 1, 2, 3),

        # gets this set
        function('get_set', ret('get_set', 
            self.set()
        ),'self'),

        # add an element to the set
        # also testing the 'as' function
        function('add_element', self.set(
            as('_t', self.set(), _t.add(_el))
        ),'self', '_el')
    )),

    # test set
    @ set = test_set(),

    equals(set.set(), {0, 1, 2, 3}) ??,
    equals(set.get_set(), {0, 1, 2, 3}) ??,

    # add an element to the set
    set.add_element(4),
    
    # assert the element was added
    equals(set.get_set(), set.set(), {0, 1, 2, 3, 4}) ??,

    # making another test_set() with its own set values
    @ set2 = test_set(set('hello', 'hello', 'mason')),

    # assert the set is correct
    equals(set2.get_set(), set2.set(), {'hello', 'mason'}) ??,
    # assert the first set is still the first set
    equals(set.get_set(), set.set(), {0, 1, 2, 3, 4}) ??,


    # testing class constructor bc bored
    class('hello', =>(

        @ val1=1,
        @ val2=2,
        @result=3,

        # constructor
        function('const',
            self.result(op.add(self.val1(), self.val2())),
        'self')
        
    )),

    # test class
    @ hey = hello(),

    # assert the result is correct
    equals(hey.result(), 3) ??,

    # assert the values are correct
    equals(hey.val1(), 1) ??,
    equals(hey.val2(), 2) ??,

    # create a new class with different val1 and val2
    @ hey2 = hello(3, 4),

    # assert the result is correct
    equals(hey2.result(), 7) ??,

    # creating a class with different values
    # after needing default attribute prior to the
    # attribute needing changed
    @ hey3 = hello(static(hello.val1()), 5),

    # assert the result is correct
    equals(hey3.result(), 6) ??,

    # return
    ret('test_sets', 1)
))
# -------------------------------------------

# ------------------ TESTING BASE INTERPRETER SYNTAX UPDATES ------------------


# -------------------------------------------


# ---------------------------------------------- RUNNING TESTS ----------------------------------------------

# test information
@ tests_ran = 0
@ test_count = 0

# macro for running tests
# (added 5/16/2023)
macro('TEST ', '__function', =>(
    thread(cat('thread', test_count.inc()), private(assert(-(__function ))))
))

# runs tests in their own private environment
# a private block inherits copies of all variables and methods from the parent context
~ run_tests() -> _

    # cleans processes for next iteration
    -- clean_processes()

    # runs basic tests
    # runs each test on a new thread    
    -- TEST test_var()
    -- TEST test_math()
    -- TEST test_strings()
    -- TEST test_arrays()
    -- TEST test_msn2embed()
    -- TEST test_classes()
    -- TEST test_complex()
    -- TEST test_complex2()
    -- TEST test_random()
    -- TEST test_simple_loops()
    -- TEST test_simple_cond()
    -- TEST test_html()
    -- TEST test_enclosing()
    -- TEST test_destroy()

    # tests post macro functionality
    -- private(assert(test_postmacros()))

    # next test block
    -- TEST test_function()
    -- TEST test_redirect()
    -- TEST test_userfunc_with_args()
    -- TEST test_op()
    -- TEST test_more_global_methods()
    -- TEST test_paren_macro()
    -- TEST test_other_stuff()
    -- TEST test_global_methods()
    -- TEST test_int_methods()
    -- TEST subclasses()
    -- TEST jointmacros()
    -- TEST test_sets()


    # testing macros
    -- TEST => (
        assert(test_macros()),
        add_and_export()
    )

    -- TEST base_syntax_updates()


    # test is not run on another thread to avoid file reading conflicts
    -- private(assert(test_user_syntax()))
    -- private(=>(
        
        # runs thread based test
        assert(test_threads()),

        # counts threads created in this context
        add_and_export()
    ))

    # tests processes, currently only implemented for windows
    -- if (<< |windows()| and not |?tests_ran?| >>, =>(

        # processes testing
        private(=>(
            assert(test_processes()),
            add_and_export()
        ))
    )),
    
    # adds threads that launch the tests
    -- add_threads()

    -- @ tests_ran = 1
    -- var('_', True)



# start the timer
timer_start()

# iteration count
var('iterations', 7)

# launches the tests multiple times to ensure integrity
for (0, ?iterations?, 'i', =>(
    print('--- iteration', ?i? + 1, '---'),
    assert(run_tests()),
    print('------------------')
))

# prints accounting information
print_threads()



# completes the validator
print('[+] fin in', cat(timer_runtime(), 's'))

# stops the validator
stop()