# validates integrity of the current MSNScript2 interpreter
#
# author : Mason Marker
# date : 11/27/2022





# ------------------ SETUP ------------------

# imports operating system specific 'clear' console command
import ('lib/os.msn2')

# imports timing capabilities
import ('lib/timer.msn2')

# test specific accounting
var('thread_count', 0)


# accumulates the thread count for private contexts
~ add_threads() -> _
    -- add('thread_count', << len(vars()['self'].threads) >>)

~ add_and_export() -> _
    -- add('thread_count', << len(vars()['self'].threads) >>)
    -- export('thread_count')

# prints accounting information
~ print_threads() -> _
    -- print('[+] created', ?thread_count?, 'threads')
    -- print('[+] interpreted', trace.len(), 'lines')

# clear console
clear()

# -------------------------------------------

print('[+] starting, do not crtl + c / v')

# testing variables
var('a', 1)
var('b', 2)
var('c', 3)
var('d', 4)
var('e', 5)
var('f', 6)


# ------------------ VARIABLES ------------------

# tests basic variable functions
~ test_var() -> _

    -- print('[+] testing variables...')

    # asserts all variables exist in this context
    -- assert(exists('a'), exists('b'), exists('c'), exists('d'), exists('e'), exists('f'))

    # asserts that variables are being set correctly
    -- assert(?a? == 1, ?b? == 2, ?c? == 3, ?d? == 4, ?e? == 5, ?f? == 6)

    # asserts that variables are compared correctly
    -- assert(?a? < ?b?, ?b? < ?c?, ?c? < ?d?, ?d? < ?e?, ?e? < ?f?)

    # asserts that variables are being modified correctly
    -- var('a', 2)
    -- var('b', 3)
    -- var('c', 4)
    -- var('d', 5)
    -- var('e', 6)
    -- var('f', 7)

    -- assert(?a? == 2, ?b? == 3, ?c? == 4, ?d? == 5, ?e? == 6, ?f? == 7)

    # modifying variables in place
    -- add('a', 1)
    -- add('b', 1)
    -- add('c', 1)
    -- add('d', 1)
    -- add('e', 1)
    -- add('f', 1)

    -- assert(?a? == 3, ?b? == 4, ?c? == 5, ?d? == 6, ?e? == 7, ?f? == 8)

    -- sub('a', 1)
    -- sub('b', 1)
    -- sub('c', 1)
    -- sub('d', 1)
    -- sub('e', 1)
    -- sub('f', 1)

    -- assert(?a? == 2, ?b? == 3, ?c? == 4, ?d? == 5, ?e? == 6, ?f? == 7)

    -- mul('a', 2)
    -- mul('b', 2)
    -- mul('c', 2)
    -- mul('d', 2)
    -- mul('e', 2)
    -- mul('f', 2)

    -- assert(?a? == 4, ?b? == 6, ?c? == 8, ?d? == 10, ?e? == 12, ?f? == 14)

    -- div('a', 2)
    -- div('b', 2)
    -- div('c', 2)
    -- div('d', 2)
    -- div('e', 2)
    -- div('f', 2)

    -- assert(?a? == 2, ?b? == 3, ?c? == 4, ?d? == 5, ?e? == 6, ?f? == 7)


    -- var('_', True)


# -------------------------------------------



# ------------------ MATH ------------------

# tests basic math functions   
~ test_math() -> _

    -- print('[+] testing math...')

    # asserts addition works correctly
    -- assert(1 + 1 == 2, 2 + 2 == 4, 3 + 3 == 6, 4 + 4 == 8, 5 + 5 == 10, 6 + 6 == 12)

    # asserts subtraction works correctly
    -- assert(1 - 1 == 0, 2 - 2 == 0, 3 - 3 == 0, 4 - 4 == 0, 5 - 5 == 0, 6 - 6 == 0)

    # asserts multiplication works correctly
    -- assert(1 * 1 == 1, 2 * 2 == 4, 3 * 3 == 9, 4 * 4 == 16, 5 * 5 == 25, 6 * 6 == 36)

    # asserts division works correctly
    -- assert(1 / 1 == 1, 2 / 2 == 1, 3 / 3 == 1, 4 / 4 == 1, 5 / 5 == 1, 6 / 6 == 1)

    # asserts modulo works correctly
    -- assert(1 % 1 == 0, 2 % 2 == 0, 3 % 3 == 0, 4 % 4 == 0, 5 % 5 == 0, 6 % 6 == 0)

    # asserts exponentiation works correctly
    -- assert(1 ** 1 == 1, 2 ** 2 == 4, 3 ** 3 == 27, 4 ** 4 == 256, 5 ** 5 == 3125, 6 ** 6 == 46656)

    # asserts that integer division works correctly
    -- assert(1 // 1 == 1, 2 // 2 == 1, 3 // 3 == 1, 4 // 4 == 1, 5 // 5 == 1, 6 // 6 == 1)

    # modifies variables
    -- var('a', 2)
    -- var('b', 3)
    -- var('c', 4)
    -- var('d', 5)
    -- var('e', 6)
    -- var('f', 7)

    # asserts the same for variables
    -- assert(?a? + ?a? == 4, ?b? + ?b? == 6, ?c? + ?c? == 8, ?d? + ?d? == 10, ?e? + ?e? == 12, ?f? + ?f? == 14)
    -- assert(?a? - ?a? == 0, ?b? - ?b? == 0, ?c? - ?c? == 0, ?d? - ?d? == 0, ?e? - ?e? == 0, ?f? - ?f? == 0)
    -- assert(?a? * ?a? == 4, ?b? * ?b? == 9, ?c? * ?c? == 16, ?d? * ?d? == 25, ?e? * ?e? == 36, ?f? * ?f? == 49)
    -- assert(?a? / ?a? == 1, ?b? / ?b? == 1, ?c? / ?c? == 1, ?d? / ?d? == 1, ?e? / ?e? == 1, ?f? / ?f? == 1)
    -- assert(?a? % ?a? == 0, ?b? % ?b? == 0, ?c? % ?c? == 0, ?d? % ?d? == 0, ?e? % ?e? == 0, ?f? % ?f? == 0)
    -- assert(?a? ** ?a? == 4, ?b? ** ?b? == 27, ?c? ** ?c? == 256, ?d? ** ?d? == 3125, ?e? ** ?e? == 46656, ?f? ** ?f? == 823543)
    -- assert(?a? // ?a? == 1, ?b? // ?b? == 1, ?c? // ?c? == 1, ?d? // ?d? == 1, ?e? // ?e? == 1, ?f? // ?f? == 1)

    # working with floats
    -- var('a', 2.0)
    -- var('b', 3.0)
    -- var('c', 4.0)
    -- var('d', 5.0)
    -- var('e', 6.0)
    -- var('f', 7.0)

    # asserts the same for variables
    -- assert(?a? + ?a? == 4.0, ?b? + ?b? == 6.0, ?c? + ?c? == 8.0, ?d? + ?d? == 10.0, ?e? + ?e? == 12.0, ?f? + ?f? == 14.0)
    -- assert(?a? - ?a? == 0.0, ?b? - ?b? == 0.0, ?c? - ?c? == 0.0, ?d? - ?d? == 0.0, ?e? - ?e? == 0.0, ?f? - ?f? == 0.0)
    -- assert(?a? * ?a? == 4.0, ?b? * ?b? == 9.0, ?c? * ?c? == 16.0, ?d? * ?d? == 25.0, ?e? * ?e? == 36.0, ?f? * ?f? == 49.0)
    -- assert(?a? / ?a? == 1.0, ?b? / ?b? == 1.0, ?c? / ?c? == 1.0, ?d? / ?d? == 1.0, ?e? / ?e? == 1.0, ?f? / ?f? == 1.0)
    -- assert(?a? % ?a? == 0.0, ?b? % ?b? == 0.0, ?c? % ?c? == 0.0, ?d? % ?d? == 0.0, ?e? % ?e? == 0.0, ?f? % ?f? == 0.0)
    -- assert(?a? ** ?a? == 4.0, ?b? ** ?b? == 27.0, ?c? ** ?c? == 256.0, ?d? ** ?d? == 3125.0, ?e? ** ?e? == 46656.0, ?f? ** ?f? == 823543.0)
    -- assert(?a? // ?a? == 1.0, ?b? // ?b? == 1.0, ?c? // ?c? == 1.0, ?d? // ?d? == 1.0, ?e? // ?e? == 1.0, ?f? // ?f? == 1.0)

    # working with negative numbers and larger decimals
    -- var('a', -2.532)
    -- var('b', -3.123)
    -- var('c', -4.123)
    -- var('d', -5.123)
    -- var('e', -6.123)
    -- var('f', -7.123)

    # asserts the same for variables
    -- assert(?a? + ?a? == -5.064, ?b? + ?b? == -6.246, ?c? + ?c? == -8.246, ?d? + ?d? == -10.246, ?e? + ?e? == -12.246, ?f? + ?f? == -14.246)
    -- assert(?a? - ?a? == 0.0, ?b? - ?b? == 0.0, ?c? - ?c? == 0.0, ?d? - ?d? == 0.0, ?e? - ?e? == 0.0, ?f? - ?f? == 0.0)
    -- assert(equals(round(?a? * ?a?), 6))
    -- assert(equals(round(?b? * ?b?), 10))
    -- assert(equals(round(?c? * ?c?), 17))
    -- assert(equals(round(?d? * ?d?), 26))
    -- assert(equals(round(?e? * ?e?), 37))
    -- assert(equals(round(?f? * ?f?), 51))

    -- assert(?a? / ?a? == 1.0, ?b? / ?b? == 1.0, ?c? / ?c? == 1.0, ?d? / ?d? == 1.0, ?e? / ?e? == 1.0, ?f? / ?f? == 1.0)

    -- var('_', True)
# -------------------------------------------




# ------------------ STRINGS ------------------

~ test_strings() -> _

    -- print('[+] testing strings...')

    # modifies variables
    -- var('a', 'hello')
    -- var('b', 'world')
    
    # asserts that strings are being set correctly
    -- assert(?a? == 'hello', ?b? == 'world')

    # asserts that strings are being concatenated correctly
    -- assert(?a? + ?b? == 'helloworld')

    # asserts that strings are being multiplied correctly
    -- assert(?a? * 2 == 'hellohello', ?b? * 2 == 'worldworld')

    # asserts that strings are being modified correctly
    -- add('a', 'hello')
    -- assert(?a? == 'hellohello')

    # replacing with converge operator <<>> (python fallback mechanism)
    -- assert(<<|?a?|.replace('hello', '') == ''>>)

    # replacing with converge operator <<>> (python fallback mechanism)
    -- assert(<<|?a?|.replace('hello', 'world') == 'worldworld'>>)

    # splitting with converge operator <<>> (python fallback mechanism)
    -- assert(<<|?a?|.split('h') == ['', 'ello', 'ello']>>)

    # getting a character in a string
    -- assert(?a?[0] == 'h')
    -- assert(?a?[1] == 'e')
    -- assert(?a?[2] == 'l')
    -- assert(?a?[3] == 'l')
    -- assert(?a?[4] == 'o')

    # special characters
    -- assert('\\' == '\\', '\'' == '\'', '\"' == '\"', '\n' == '\n', '\t' == '\t', '\r' == '\r')

    -- var('a', 'hello')

    -- a.add(' how are you?')
    -- assert(?a? == 'hello how are you?')    

    -- a.add('\n')

    # when working with special characters, you cannot use ?? syntax
    -- var('checker', 'hello how are you?\n')
    -- assert(var.equals('a', 'checker'))

    -- var('_', True)

# -------------------------------------------


# ------------------ ARRAYS AND DICTIONARIES ------------------

~ test_arrays() -> _

    -- print('[+] testing arrays...')

    # sets an array
    -- var('a', [1, 2, 3, 4, 5, 6])

    # asserts that the array is being set correctly
    -- assert(?a? == [1, 2, 3, 4, 5, 6])

    # asserts that the array is being concatenated correctly
    -- assert(?a? + [7, 8, 9, 10, 11, 12] == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

    # asserts that the array is being multiplied correctly
    -- assert(?a? * 2 == [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])

    # asserts that the array is being modified correctly
    -- a.push(7, 8, 9)
    -- assert(?a? == [1, 2, 3, 4, 5, 6, 7, 8, 9])
    -- a . push(10)
    -- assert(?a? == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

    # asserts that removen() works correctly
    -- a.push(3, 3, 3)

    # removes 2 3's from 'a'
    -- a.removen(2, 3)

    -- assert(?a? == [1, 2, 4, 5, 6, 7, 8, 9, 10, 3, 3])

    # removes 1 '1' and 1 '2' from 'a'
    -- a.removen(1, 1, 2)

    -- assert(?a? == [4, 5, 6, 7, 8, 9, 10, 3, 3])

    # remove if not exists, catches value error
    -- try(a.removen(1, 1))

    -- assert(?a? == [4, 5, 6, 7, 8, 9, 10, 3, 3])

    # tests remove
    -- a.remove(3)

    -- assert(?a? == [4, 5, 6, 7, 8, 9, 10])

    # assert contains (<<>> python fallback)
    -- assert(<< 4 in |?a?| and 5 in |?a?| and 6 in |?a?| and 7 in |?a?| and 8 in |?a?| and 9  in |?a?| and 10 in |?a?| >>)
    -- assert(<< 1 not in |?a?| and 2 not in |?a?| and 3 not in |?a?| >>)

    # indexing dictionaries
    -- @dict = { 'a': 1, 'b': [0, [4, 3]], 'c': 3, 'd': 4, 'e': {'key': 'value'}, 'f': 6 }
    -- assert(?dict?['a'] == 1)

    # WIP
    -- dict.setn(999, 'e', 'key')   
    -- assert(?dict?['e']['key'] == 999)

    -- dict.setn(999, 'b', 1, 1)
    -- assert(?dict?['b'][1][1] == 999)

    -- dict.setn(999, 'b', 1)
    -- assert(?dict?['b'][1] == 999)

    -- dict.setn(999, 'b')
    -- assert(?dict?['b'] == 999)

    -- dict.setn(999, 'a')
    -- assert(?dict?['a'] == 999)
    -- dict.setn(999, 'f')
    -- assert(?dict?['f'] == 999)

    # deep dictionary operations
    -- @deep={'1':{'2':{'3':{'4':{}}}}}
    -- deep.setn(999, '1', '2', '3', '4', '5')
    -- assert(?deep?['1']['2']['3']['4']['5'] == 999)

    -- var('_', True)

# -------------------------------------------

# ------------------ CLASSES ------------------
~ test_classes() -> _

    -- print('[+] testing classes...')

    # declares a class called 'person' with two attributes
    -- class('person', =>(
        var('name', 'unknown'),
        var('age', -1)
    ))

    # creates an instance of a class
    -- var('joe', person('joe', 20))

    -- assert(exists('joe'))

    # assert vars were set
    -- assert(equals(joe.name(), 'joe'))
    -- assert(equals(joe.age(), 20))

    # set attributes of a class
    -- joe.name('joseph')
    -- joe.age(21)

    # reassert
    -- assert(equals(joe.name(), 'joseph'))
    -- assert(equals(joe.age(), 21))

    # copy of a person
    -- var('joe2', joe.copy())

    # assert that joe2 is a copy of joe
    -- assert(equals(joe2.name(), 'joseph'))
    -- assert(equals(joe2.age(), 21))

    # assert that joe2 is not joe
    -- joe2.name('joe2')
    -- joe2.age(22)

    -- assert(equals(joe2.name(), 'joe2'))
    -- assert(equals(joe2.age(), 22))

    -- assert(not(equals(joe.name(), 'joe2')))
    -- assert(not(equals(joe.age(), 22)))

    # create a family
    -- class('family', =>(
        var('members', [])
    ))

    -- var('fam', family([]))

    -- fam.members(=>(
        var('curr', fam.members()),
        curr.push(?joe?),
        ?curr?
    ))

    -- fam.members(=>(
        var('curr', fam.members()),
        curr.push(?joe2?),
        ?curr?
    ))

    -- assert(equals(?fam?['members'][0]['name'], 'joseph'))
    -- assert(equals(?fam?['members'][0]['age'], 21))
    -- assert(equals(?fam?['members'][1]['name'], 'joe2'))
    -- assert(equals(?fam?['members'][1]['age'], 22))

    -- assert(equals(fam.members(), [?joe?, ?joe2?]))

    -- var('_', True)

# -------------------------------------------


# ------------------ COMPLEX STUFF ------------------


~ test_complex() -> _

    -- print('[+] testing complex...')
    -- var('_', assert(
        assert(assert(True), assert(not(False))),
        assert(assert(<< not |False| >>), not(not(True))),
        assert(True and True, assert(True)),
        assert(assert(True), assert(True), assert(=>(
            var('z', -1),
            add('z', 1),
            ?z? == 0
        ))),
        assert(True or False),
        assert(3 != 3 or 5 != 1, [1, 2, 3] == [1, 2, 3]),
        assert(
            True,
            assert(assert(not False), assert(True)),
            assert(True),
            not False,

            # inline function syntax => ()
            # takes any amount of instructions separated by commas
            # can be used in place of any argument or instruction
            # returns the return value of the last instruction to => ()
            => (
                var('map', {'name': 'mason', 'age': 20}),
                ?map?['name'] == 'mason' and ?map?['age'] == 20
            ),
            => (
                var('a', False),
                ?a? or True
            ),

            True,
            assert(True),
            not(not(True))
        ),
        assert(True),
        assert(assert(True), assert(True))))

        -- assert(=>(
            assert(True, True, True, not False, 5 in [5]),
            assert(3 not in {'name': 'joe'}, True, not False, <<|True|>>),
            assert(<<'key' in {'key':4}.keys() >>,
            <<|not(False)|>>,
            <<True>>,
            <<not False>>,
            True,
            not False,
            [{}, {}, {-5238595.34958259283:0}] in [[{}, {}, {-5238595.34958259283:0}], 'hello', -34534.623452345],
            True,
            << isinstance(52348238423.52348234, float) >>,
            << isinstance(-1919191.23287342837423, float) >>,
            << isinstance(5, int) >>,
            << isinstance(-523, int) >>,
            << isinstance([], list) >>,
            << isinstance({}, dict) >>,
            << isinstance('hello', str) >>
            ),
            assert(True, True, 4 == 4, -1214823.52983429 > -34928349823.482),
            assert("mason" in "my name is mason", "hello" in "  wef39i23 hello  "),
            assert(6+3==9,10==10,True,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),
            assert(1, 1, 1, 1, 1, not 0, not(0)),
            assert(True),
            =>(
                True
            ),
            not(False),

            assert(=>(=>(=>(=>(=>(=>(=>(
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
            )))))))),

            =>(assert(True), assert(True), True),
            =>(assert(True, True, assert(assert(True), True))),
            =>(assert(not(exists('foiajweofi')))),
            =>(<<|=>(assert(1, 1))|>>),
            =>(assert(<<1>>), <<0+1-1+1>>),
            =>(
                var('string', '
                    hello, this is a note.

                    [1, 2, 3, 4, 5]   |  | !@#$%^&*())!@#$%^&*()_)(*&^%$#@
                    n\t\n\t\t\\rr\t\\nt\\tr\t\\yn\y\
                '),
                'hello' in ?string? and 
                'this is a note.' in ?string? and
                '[1, 2, 3, 4, 5]' in ?string?
            ),
            1,
            =>(
                not False
            ),
            1,
            1 >= 1,
            'mason'[::-1] == 'nosam',
            ',,,{}][][]{}{}][][][()()()@#$%^&*()'==',,,{}][][]{}{}][][][()()()@#$%^&*()',
            =>(1)
            =>(assert(1, 1, 1, 1, 1, 1))



        ))


    -- var('_', True)


# ------------------ ACTUAL STUFF HAPPENING : THREADS ------------------


# semaphore support
import ('lib/semaphore.msn2')

# tests thread subroutines
~ test_threads() -> _

    -- print('[+] testing threads...')

    -- thread('t1', =>(
        var('count', 0),
        for (0, 10, 'i', =>(
            add('count', 1)
        )),
        assert(?count? == 10)
    ))

    # joins with newly created thread
    -- join('t1')

    # assert count is 10
    -- assert(?count? == 10)

    # testing semaphores
    # main thread grabs the semaphore before the new
    # thread is created
    -- var('sem', semaphore(True, ''))
    -- var('a', 0)

    # creates a new thread
    -- thread('t2', =>(

        # wait for the resource to be unlocked
        wait(not(sem.held())),
        sem.held(True),

        # perform work
        add('a', 1),

        # release the semaphore
        sem.message('finished'),
        sem.held(False)

    ))

    -- assert(sem.held())
    -- assert(equals(sem.message(), ''))

    # give the thread the semaphore
    -- sem.held(False)

    # waits for the thread to write a message to the semaphore
    -- wait(equals(sem.message(), 'finished'))

    # assert the thread released the semaphore
    -- assert(not(sem.held()))

    # assert that the work was finished
    -- assert(?a? == 1)

    # joins threads to avoid thread counting errors
    -- join('t1')
    -- join('t2')

    -- var('_', True)


# -------------------------------------------




# ------------------ ACTUAL STUFF HAPPENING : MULTIPROCESSING ------------------

# multiprocessing support
import ('lib/processes.msn2')

# MSNScript2 is capable of multiprocessing, follow the documentation below
~ test_processes() -> _ 

    -- print('[+] testing processes...')

    # creates a new process
    # second argument to fork() must be async() to save
    # the block of code for use by the newly created process
    -- fork('process1', async(=>(

        # process performs work
        var('forkvar', 0),
        assert(exists('forkvar')),
        for (0, 10, 'i', =>(
            add('forkvar', 1)
        )),
        assert(?forkvar? == 10)
    )))

    # joins with the process
    # same syntax as threads because fork() is a user method imported from lib/processes.msn2
    # thats starts the process from a new thread
    -- join('process1')
    
    -- assert(not(exists('forkvar')))

    # test 2
    -- var('a', 0)

    # starts two processes that perform work
    -- for(0, 2, 'i', =>(
        fork(?i?, async(=>(

            print('[+] testing process', cat(?i?, '...')),

            # process specific variables
            var('a', 0),
            var('b', 0),
            var('c', 0),
            assert(exists('a'), exists('b'), exists('c')),

            # if process 0
            if (?i? == 0, =>(

                # assert the variables exists
                assert(exists('a'), exists('b'), exists('c')),
                assert(not(exists('d')), not(exists('e')), not(exists('f'))),



                # modify the variables
                add('a', 1),
                add('b', 1),
                add('c', 1),

                # assert the variables were modified
                assert(?a? == 1, ?b? == 1, ?c? == 1),

            ), 

            # else if process 1
            =>(
                # same as 0
                assert(exists('a'), exists('b'), exists('c')),
                assert(not(exists('d')), not(exists('e')), not(exists('f'))),
                add('a', 10),
                add('b', 10),
                add('c', 10),
                assert(?a? == 10, ?b? == 10, ?c? == 10),
            ))
        )))
    ))

    # joins with the first process created
    -- join(0)

    -- var('_', True)
# -------------------------------------------




# ------------------ ACTUAL STUFF HAPPENING : ENDPOINTS ------------------

var('terminate', False)


# hosting an endpoint
~ test_endpoints() -> _

    -- print ('[+] testing endpoints')

    # endpoints should reside in a new process
    -- fork('ep1', async(=>(
        
        # starts a new endpoint on localhost:5000 on a new thread
        thread('t', ENDPOINT('127.0.0.1', 5000, '/', {})),

        # waits for a signal to end the process, with a 0.05s interval
        wait(equals(GET('127.0.0.1', 5000, '/'), {'leave': 1}), sleep(0.5)),

        # stops the forked process
        stop()
    )))
    
    # wait for endpoint to become active
    -- wait(equals(GET('127.0.0.1', 5000, '/'), {}), sleep(0.5))

    # assert endpoint is responsive
    -- assert(equals(GET('127.0.0.1', 5000, '/'), {}))

    # asserts post is working
    -- assert(equals(POST('127.0.0.1', 5000, '/', {'a': 1}), {'a': 1}))

    # asserts get is working
    -- assert(equals(GET('127.0.0.1', 5000, '/'), {'a': 1}))

    # asserts deletion is working
    -- assert(equals(DELETE('127.0.0.1', 5000, '/'), {}))

    # stops the endpoint's host process
    -- assert(equals(POST('127.0.0.1', 5000, '/', {'leave': 1}), {'leave': 1}))

    # this should be the last test listed, 
    # and the last test to finish, 
    # so stop() ends the validator program
    -- print('[+] shutting down validator and endpoint...')

    # ends the timer and prints finishing boot environment
    -- print('[+] fin in', cat(timer_runtime(), 's'))

    # imports clean_processes()
    -- import('lib/processes.msn2')

    # cleans processes
    -- clean_processes()

    -- add_threads()

    # includes the thread that launched the endpoints tests
    -- add('thread_count', 1)

    # prints accounting information
    -- print_threads()

    # stops the program, as server endpoints can only be 
    -- stop()

# -------------------------------------------




# ------------------ RANDOMNESS ------------------

# random implementation includes
# a single system call 'random()'
~ test_random() -> _

    -- print('[+] testing random...')

    # runs tests multiple times for random function
    -- for (0, 100, 'i', =>(

        # random() with 0-1 arguments returns a float between
        # 0-1
        var('r', random()),
        assert(?r? < 1 and ?r? >= 0),

        # random() with 2 arguments returns a range between the
        # two values passed
        var('r2', random(1, 2)),
        assert(?r2? < 3 and ?r2? >= 1),

        var('r3', random(0, 100)),
        assert(?r3? < 100 and ?r3? >= 0),

        # a random() with 3 arguments
        # defaults the return value to an integer,
        # effectively implementing float and integer random
        # capabilities from random()
        var('r4', random(0, 100, <<>>)),

        # asserts the value is an integer with python fallback
        assert(<< isinstance(|?r4?|, int) >>),
        assert(?r4? < 100 and ?r4? >= 0),

        # creates an array of random values with python fallback
        var('r5', <<[|random()|,|random(0, 10)|,|random(0, 10, '')|]>>),

        # assert type of random
        assert(<< isinstance(|?r5?[0]|, float) >>, not(<< isinstance(|?r5?[0]|, int) >>)),
        assert(<< isinstance(|?r5?[1]|, float) >>, not(<< isinstance(|?r5?[1]|, int) >>)),
        assert(<< isinstance(|?r5?[2]|, int) >>, not(<< isinstance(|?r5?[2]|, float) >>)),

        # assert range of random
        assert(?r5?[0] < 1 and ?r5?[0] >= 0),
        assert(?r5?[1] < 10 and ?r5?[1] >= 0),
        assert(?r5?[2] < 10 and ?r5?[2] >= 0)
    ))

    -- var('_', True)
    
# -------------------------------------------


# ------------------ MSN1 FALLBACK ------------------

# msn1 fallback can be used for a better ease when
# operating on variables as depicted in this test

# tests '@' syntax to msnscript1 fallback functionality
~ test_msn1_fallback() -> _
    
    -- print('[+] testing msn1 fallback...')

    # preceeding a LINE with '@' indicates an msn1 fallback request
    -- @ integer = 1

    # assert the fallback worked
    -- assert(exists('integer'))
    -- assert(?integer? == 1)

    # testing increment
    -- @ integer+= 1
    -- assert(?integer? == 2)

    # testing decrement
    -- @ integer-=1
    -- assert(?integer? == 1)

    # testing * and /
    --@integer*=3
    -- assert(?integer? == 3)

    -- @ integer /= 3
    -- assert(?integer? == 1)

    # testing other things
    -- @ integer = integer + integer
    -- assert(?integer? == 2)

    -- @integer2 = integer
    -- assert(exists('integer2'), ?integer2? == ?integer?)

    --@ string = "hello this is a string"
    -- assert(?string? == 'hello this is a string')
    
    --@ string += " yes"
    -- assert(?string? == "hello this is a string yes")

    # primal msn1 loop mechanism, similar to simple loop syntax
    -- @ integer = 0
    -- @ {0:5:i} integer += i
    -- assert(?integer? == 10)

    # primate msn1 conditional mechanism
    --@ integer=0
    -- assert(not(?integer?))

    # arrays and objects
    --@ array = [1, -2, 3] 
    --@ array2 = ["string", 453.4234, -231.67345, ["0"]]
    --@ object = {'obj': [8, '!'], 'key': 'value'}

    -- assert(?array? == [1, -2, 3])
    -- assert(?array2? == ["string", 453.4234, -231.67345, ["0"]])
    -- assert(?object? == {'obj': [8, '!'], 'key': 'value'})

    # @ to msn2 fallback
    # use || to specific an msn2 function to be evaluated within the @ syntax

    -- @ a = |3|
    -- assert(?a? == 3)

    -- @ a = |3 + 3|
    -- assert(?a? == 6)

    -- @ a = |assert(True)|
    -- assert(?a?)

    -- @ a += |False|
    -- assert(?a?)

    # more advanced usage
    -- @ a = |assert(True)|+|assert(True, True, assert(1, =>(1, []==[])))| * 5 - 1
    -- assert(?a? == 5)

    -- @ a = |max([1, 2, 3, 4, 5])|
    -- assert(?a? == 5)

    -- var('_', True)

# -------------------------------------------



# ------------------ SIMPLE LOOPS ------------------



# simple loops are written as functions with the below syntax
# two integers, and an index variable before the loop's block arguments within the ()
# the arguments to the simple loop between the || cannot be anything but an integer

# tests another loop approach
~ test_simple_loops() -> _

    -- print('[+] testing simple loops...')

    -- @ a = 0

    # simple loop syntax
    -- 0|2|i (add('a', 1))

    -- assert(?a? == 2)

    -- @ a = 0
    --0|5|i(add('a', ?i?))
    -- assert(?a? == 10)

    -- @ a = 0
    -- 0 | 3 | i (add('a', 1))
    -- assert(?a? == 3)

    # brute test
    --@a=0
    --     5    |   2 |_(add(   'a', 1))
    -- assert(1 , ?a? == 3)
    
    --@a=0

    # nested simple loops
    -- 2 | 6 | i    (1|4|j  (add('a', 1)))
    -- assert(?a? == 12)

    # uses msn1 fallback to simplify returning process, see returning tests for returning requirements
    -- @ _ = 1

# -------------------------------------------

# ------------------ SIMPLE CONDITIONALS ------------------

# simpler conditional implementation
# ? syntax is a function, meaning it requires (true_block, false_block) for a block to execute
# the argument to ? cannot be a function itself
~ test_simple_cond() -> _
    -- print('[+] testing simple cond...')
    
    # assert syntax is functional
    -- ? True (assert(True), assert(False))
    -- ? False (assert(False), assert(True))

    # slightly more advanced variations
    -- @ a = 1
    -- ? ?a? (assert(True), assert(False))
    -- ? not ?a? (assert(False))

    # no () can exist between ? and its blocks in ()
    # --v----------------v
    -- ? 0 (assert(False), assert(True))

    -- ? 0 (assert(False))
    -- @_=1

# -------------------------------------------

# ------------------ DEFINING SYNTAX ------------------

# the system call syntax() is used to define new syntax
# syntax() takes three arguments
# the created syntax will exist in all contexts across all threads
# 
# it is safe and highly recommended to choose unique tokens to avoid symbolic / naming conflicts within 
# base MSNScript2 syntax
#
# first argument indicates the token surrounding a block of text in an MSNScript2 argument, this block of text
# does not need to conform to MSNScript2 / Python syntax
#
# second argument stores the internals surrounded by the token specified
# as the first argument
#
# third argument is what should be returned according to the line confined within the new token
#
~ test_user_syntax() -> _
    
    -- print('[+] testing user syntax...')

    # defines a new syntax for the '!!!' token
    -- syntax('!!!', 'line', =>(
        assert(exists('line')),
        assert(?line? == ' 5 + 2 - 6 * 2 '),
        assert(<< |eval(?line?)| == -5 >>),
    ))

    # demonstrating the syntax
    -- !!! 5 + 2 - 6 * 2 !!!

    # creating a new syntax
    -- syntax('goof', 'line', =>(
        @ a = 1000,
        1
    ))

    # asserting syntax
    -- assert(goofgoof, exists('a'), ?a? == 1000)
    -- assert(goof, goofgoof, =>(goof))


    # more practical implementations

    # defines and writes to a single local storage by which programs can communicate
    -- syntax('LOCAL', 'line', =>(
        file.mkdir('localstorage'),
        file.create('localstorage/local.txt'),
        file.write('localstorage/local.txt', ?line?),
        file.read('localstorage/local.txt')
    ))

    # asserts the write was correct
    -- assert(<< |LOCAL 5729348570234 LOCAL| == ' 5729348570234 ' >>)
    -- assert(<< |LOCAL hello! LOCAL| == ' hello! ' >>)
    -- assert(<< |LOCAL this is some text LOCAL| == ' this is some text ' >>)

    # more advanced syntax
    # creates an array out of all things surrounded by '---'
    # when inside the user defined context
    -- syntax('$', 'line', =>(
        var('____', []),
        var('insides', between('-', ?line?)),
        each(?insides?, 'line2', =>(
            ____.push(?line2?)
        )),
        ?____? 
    ))

    # create quicker assertion syntax
    -- syntax('!!', 'line', =>(
        each(split(?line?, '--'), 'line2', =>(
            if(not(-(?line2?)), print('[-] assertion failed: ' + ?line?)),
        ))
    ))

    # demonstrating new syntax
    -- .. !! -- True -- 1 -- [1, 2, 3, 4] == [1, 2, 3, 4] -- assert(assert(True)) !!

    # using =>() to invoke multiline interpretation
    -- =>(
        !!
        True
        --
        True
        --
        # we use th previous syntax to form an array
        equals($ -1- -2- -9- $, ['1', '2', '9'])
        !!
    )

    # we use the new syntax to define an array of strings,
    # we then return this array to the python fallback mechanism (<<>>)
    # where we rely on Python to perform list comprehension to bring the integers
    # out of each string element
    -- assert(equals(var('array', << [int(i) for i in |$ -1- -2- -3- -4- -5- $|] >>), [1, 2, 3, 4, 5]))
    -- assert(?array? == [1, 2, 3, 4, 5])
    # demonstrates the new syntax
    -- var('array', $$ -5- -3- -0-   $$)
    -- var('array', << [int(i) for i in |?array?|] >>)
    -- assert(?array? == [5, 3, 0])    

    
    # pretend global variable
    -- @ a = 0

    # defines a new syntax to make an increment of a variable easier
    -- syntax('++', 'line', =>(
        @ a += 1
    ))

    # assert functionality
    -- assert(?a? == 0)
    -- ++
    -- assert(?a? == 1)
    -- 0|10|_(++)
    -- assert(?a? == 11)
    -- ? True (=>(++, =>(
        0|5|_ (++)
    )))
    -- assert(?a? == 17)
    
    # paired user syntax tags still act as a single call to that syntax
    -- =>(
        ++
        ++
    )

    -- assert(?a? == 18)
    
    -- @ _ = 1
# -------------------------------------------

# ------------------ COMPLEX 2 ------------------

~ test_complex2() -> _

    -- print('[+] testing complex 2...')


    -- @ _ = 1


# -------------------------------------------

# ------------------ TESTS MACROS ------------------

# imports serialization for thread naming
import('lib/serial.msn2')

# opens a new serialization variable
serial_open('thread')

# MSNScript2 has both the ability to create new syntax as well as new macros
#
# macros are similar to syntax, however they are confined to a single line.
# any text after the macro will be passed to the macro function,
# where the user should handle the return value
#
# macro arguments should be literals in most cases
~ test_macros() -> _

    -- print('[+] testing macros...')

    # defines a new macro to create a thread, returning its name
    # any line of code preceeded with a ':' will 
    # be executed on a new thread
    -- macro(':', 'line', =>(
        @ name = |serial_next('thread')|,
        thread(?name?, -(?line?)),
        ?name?
    ))

    # demonstrates the new macro
    -- : assert(True, 1, not(False))
    
    # creates a thread on a new context that runs an assertion
    -- : new(=>(
        assert(not(exists('a')), not(exists('b')), not(exists('c'))),
        assert(True, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
    ))

    # macros working together
    # creating subthread
    -- : : =>(
        @ v = 3,
        assert(exists('v'), ?v? == 3),
    )

    # quicker assertion
    -- macro('!', 'line', assert(-(?line?)))

    -- =>(! True, !not(False))

    -- ! not False

    # creates a few threads that make some assertions
    -- : : : =>(!True, !1, !not 0)


    -- @ _ = 1
# -------------------------------------------

# ------------------ TESTS POSTMACROS ------------------

# tests the concept of postmacros, which in turn create a new syntax that should exist
# at the end of any single line of code
# when a line is succeeded by a postmacro token, a function
# will be invoked on the line preceeding the postmacro
# this function is defined by the user
# 
# similarly to macros, if a 4th argument is added, the third
# argument as a function is ignored and a value is returned instead
~ test_postmacros()->_
    
    -- print('[+] testing postmacros...')

    # creates a post macro for a more English approach to asserting
    # i guess you could call it questioning lol
    -- postmacro('??', 'line', =>(
        assert(-(?line?))
    ))

    # demonstrates the postmacro
    -- True??
    -- not False and True ??
    -- assert(True, 1, 1)??

    # 4th argument added
    -- postmacro('_PI_', '__unused', None, 3.14)
    -- assert(equals(_PI_, 3.14), not(equals(5.123, _PI_)))
    
    # floors a number
    -- postmacro('VVV', '__expression', =>(
       math.floor(-(?__expression?))
    ))

    # ceils a number
    -- postmacro('^^^', '__expression', =>(
        math.ceil(-(?__expression?))
    ))

    # divides a number by 2
    -- postmacro('BY2', '__expression', =>(
        << |-(?__expression?)| / 2 >>
    ))

    -- assert(equals(3, 3.438732 VVV))
    -- assert(.438275^^^)
    -- assert(1.43254394382743928VVV)

    -- assert(equals(4 BY2, 2), 2 BY2)

    # postmacros can be chained, similarly to macros
    -- assert(equals(4 BY2 BY2, 1))

    # using multiple postmacros
    # divides by 2, then floors
    -- assert(equals(9 BY2 VVV, 4))
    -- assert(equals(6.234^^^ BY2 VVV, 3))

    -- @ _ = 1
# -------------------------------------------

# ------------------ TESTS ENCLOSING SYNTAX ------------------

# tests integrity of an enclosing syntax
~ test_enclosing() -> _

    -- print('[+] testing enclosing syntax...')

    # creates an enclosing macro surrounded by the start and end token,
    # invoked by preceeding a line with a '(', similarly to the previous
    # macro, postmacro, and syntax definitions

    # SAFELY extracts a variable's value
    -- enclosedsyntax('^', '^', '__line', val(val('__line')))

    -- @v = 'hello\n how are you?'

    -- assert(equals(^v^, 'hello\n how are you?'))


    -- @ _ = 1

# -------------------------------------------


# ------------------ TESTS HTML ------------------

# tests html functions
~ test_html()->_
    -- print('[+] testing html')

    -- @_=1

# -------------------------------------------


# ---------------------------------------------- RUNNING TESTS ----------------------------------------------

@ tests_ran = 0

# runs tests in their own private environment
# a private block inherits copies of all variables and methods from the parent context
~ run_tests() -> _

    # cleans processes for next iteration
    -- clean_processes()

    # runs basic tests
    # runs each test on a new thread    
    -- thread('vars', private(assert(test_var())))
    -- thread('math', private(assert(test_math()))) 
    -- thread('strings', private(assert(test_strings())))
    -- thread('arrays', private(assert(test_arrays())))
    -- thread('classes', private(assert(test_classes())))
    -- thread('complex', private(assert(test_complex())))
    -- thread('complex2', private(assert(test_complex2())))
    -- thread('random', private(assert(test_random())))
    -- thread('msn1', private(assert(test_msn1_fallback())))
    -- thread('loops', private(assert(test_simple_loops())))
    -- thread('cond', private(assert(test_simple_cond())))
    -- thread('html', private(assert(test_html())))
    -- thread('enclosing', private(assert(test_enclosing())))


    # macros testing
    -- thread('macros', private(=>(
        assert(test_macros()),
        add_and_export()
    )))

    # tests post macro functionality
    -- private(assert(test_postmacros()))

    # test is not run on another thread to avoid file reading conflicts
    -- private(assert(test_user_syntax()))
    -- private(=>(
        
        # runs thread based test
        assert(test_threads()),

        # counts threads created in this context
        add_and_export()
    ))

    # tests processes, currently only implemented for windows
    -- if (<< |windows()| and not |?tests_ran?| >>, =>(

        # processes testing
        private(=>(
            assert(test_processes()),
            add_and_export()
        ))

      #  private(thread('tep', test_endpoints()))
    )),
    
    # adds threads that launch the tests
    -- add_threads()

    -- @ tests_ran = 1
    -- var('_', True)



# start the timer
timer_start()

# iteration count
var('iterations', 7)

# launches the tests multiple times to ensure integrity
for (0, ?iterations?, 'i', =>(
    print('--- iteration', ?i? + 1, '---'),
    assert(run_tests()),
    print('------------------')
))

# prints accounting information
print_threads()



# completes the validator
print('[+] fin in', cat(timer_runtime(), 's'))

# stops the validator
stop()