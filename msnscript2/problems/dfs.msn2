# tests a depth first search algorithm
# author : Mason Marker (its obvious at this point)

# clear the console
import('lib/os.msn2')
clear()


# create a class for a graph
class('graph', =>(

    # adjacency list
    @ adj = [],

    # compute dfs from one node to another
    function ('dfs', =>(

        # path from start to end
        @ _path = [],

        # visited nodes
        @ visited = [],

        # stack for dfs
        @ stack = from(from(start.val(), _path.val())),

        # while the stack is not empty
        while (not(stack.empty()), =>(
            
            # pop the top vertex and path
            @ _curr = stack.pop(),
            @ _vertex = _curr.get(0),
            @ _path = _curr.get(1),
            # if the vertex is not in visited
            if (not(visited.has(_vertex.val())), =>(

                # add the vertex to the visited list
                visited.add(_vertex.val()),

                # add the vertex to the path
                _path.add(_vertex.val()),

                # if the vertex is the end
                if (_vertex.equals(end.val()), =>(

                    # return the path
                    ret('dfs', _path.val()),

                    print('returning:', _path.val())

                )),


                # for each neighbor of the vertex
                each(=>(
                    @_adj = self.adj(),
                    _adj.get(_vertex.val())
                ), 'neighbor', =>(
                    # if the neighbor has not been visited
                    if (not(visited.has(neighbor.val())), =>(
                        # push the neighbor and path to the stack
                        print('stack: ', stack.add(from(from(neighbor.val(), _path.val()))))
                    ))
                ))
            ))
        )),
        ret('dfs', _path.val())
    ), 'self', 'start', 'end'),

    # print the graph
    function('print', =>(
        @_curr_node = 0,
        each(self.adj(), 'neighbors', =>(
            print(_curr_node.val(), '->', neighbors.join(', ')),
            _curr_node.++()
        ))
    ), 'self')
))

# create graph, providing adjacency list
@ _graph = graph(
    [
        [2, 3],
        [3, 4],
        [0, 3],
        [0, 1, 2, 4],
        [1, 3]
    ]
)


# print the graph
_graph.print()


# print the graph from start to end
print(
    "shortest path from", @ start = 0, 'to', @ end = 4, ':', =>(

        # run dfs algorithm and print the shortest path
        @ shortest = _graph.dfs(start.val(), end.val()),
        shortest.join('->')
    )
)
